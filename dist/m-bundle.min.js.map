{"version":3,"file":"m-bundle.min.js","sources":["../src/utils.js","../src/m.js"],"sourcesContent":["// m, etc.\r\nexport const isEmptyArray = a => Array.isArray(a) && a.length < 1;\r\nexport const isObject = o => null != o && 'object' === typeof o; // null is #NotOurObject\r\nexport const isEmptyObject = o => isEmptyArray(Object.keys(o));\r\nexport const toArray = a => isObject(a) && a.length >= 0 ? Array.from(a) : [];\r\nexport const reduce = (initial, a, cb) => toArray(a).reduce((acc,x)=>{ cb(acc,x); return acc; }, initial);\r\nexport const objectKeys = o => isObject(o) ? Object.keys(o) : [];\r\nexport const pick = (o, ...keys) => reduce({}, objectKeys(o).filter(k=> keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const omit = (o, ...keys) => reduce({}, objectKeys(o).filter(k=>!keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const setAdd = (s, ...vals) => vals.forEach(v=>s.add(v));\r\nexport const resolve = (o, ...path) => {\r\n\t// TODO: could optimize this to generate less GC with pattern matching\r\n\t// TODO: remove anything that creates unnecessary arrays, especially use pattern matching,\r\n\t// TODO: and stop returning empty {} or [] for convenience sake. check it on iterate, instead.\r\n\tif (!isObject(o) || path.length < 1)\r\n\t\treturn { has: isObject(o) && path.length < 1, o: o, key: path[0] };\r\n\telse if (1 === path.length)\r\n\t\treturn { has: Object.hasOwnProperty.call(o, path[0]), o: o, key: path[0] };\r\n\telse return resolve(o[path.shift()], ...path);\r\n};\r\nexport const has = (o, ...path) => undefined === path[0] ? false : resolve(o, ...path).has;\r\nexport const get = (alt, o, ...path) => {\r\n\tconst r = resolve(o, ...path);\r\n\treturn r.o && r.o[r.key] || alt;\r\n};\r\nexport const getm = (o, ...path) => get(`MISSING_${path[path.length-1]}`, o, ...path);\r\nexport const set = (val, o, ...path) => {\r\n\tif (path.filter(is).length < 1) return o; // no-op\r\n\tlet key = path.pop(), c = o, part, i = 0, len = path.length;\r\n\tfor (;i<len;i++) {\r\n\t\tpart = path[i];\r\n\t\tif (null == c[part]) c[part] = 'number' === typeof path[i+1] ? [] : {};\r\n\t\tc = c[part];\r\n\t}\r\n\treturn c[key] = val;\r\n};\r\nexport const change = (alt, cb, o, ...path) =>\r\n\tset(cb(get(alt, o, ...path)), o, ...path);\r\nexport const isString = s => 'string' === typeof s;\r\nexport const isStringEmpty = s => null == s || '' === s;\r\nexport const joinStringIfNotEmpty = (a,delim,b) => isStringEmpty(a) ? b : a + delim + b;\r\nexport const isFunction = (fn,paramCount) => 'function' === typeof fn && (null == paramCount || fn.length === paramCount);\r\nexport const not = b => isFunction(b) ? (...args)=>!b(...args) : !b;\r\nexport const map = (a,cb) => {\r\n\tlet t;\r\n\treturn null == a ? undefined :\r\n\t\tArray.isArray(a) ? (a.map((v,i) => cb(v,i,i,a.length))) :\r\n\t\tisObject(a) ? (t=Object.keys(a),t.map((k,i)=>cb(a[k],k,i,t.length))) :\r\n\t\ta;\r\n};\r\n\r\nexport const data = (()=>{\r\n\tlet l, s;\r\n\tconst r = el => new Proxy(\r\n\t\tnull != el && (s.has(el) ? s.get(el) : (l={},s.set(el,l),l)), {\r\n\t\tget: (o,k) => o ? o[k] : undefined,\r\n\t\tset: (o,k,v) => o ? (o[k] = v) : undefined,\r\n\t})\r\n\tr.flush = () => { s = new WeakMap() };\r\n\tr.flush();\r\n\treturn r;\r\n})();\r\nexport const then2 = (p,cb) => p.then(v=>cb(null, v), e=>cb(e));\r\nexport const call = (fn, ...args) => { if ( isFunction(fn)) return fn(...args) };\r\nexport const toStringValue = v => null == v ? '' : isObject(v) ? JSON.stringify(v) : v;\r\nexport const notNullOrEmptyElse = (v, defaultValue) => null != v && '' !== v ? v : defaultValue;\r\nexport const prop = function(el, ns, k, v) {\r\n\tif (null == el || arguments.length < 3) return;\r\n\tconst [key,prefix] = k.split(':').reverse();\r\n\tif (3 === arguments.length) {\r\n\t\tif (null == prefix) return notNullOrEmptyElse(el.getAttribute(key), undefined);\r\n\t\telse return notNullOrEmptyElse(el.getAttributeNS(ns[key], key), undefined);\r\n\t}\r\n\telse if (undefined === v) {\r\n\t\tif (null == prefix) el.removeAttribute(key);\r\n\t\telse el.removeAttributeNS(ns[key], key);\r\n\t}\r\n\telse {\r\n\t\tif (null == prefix) el.setAttribute(key, null == v ? '' : v);\r\n\t\telse {\r\n\t\t\tel.setAttributeNS(ns[key], key, null == v ? '' : v);\r\n\t\t}\r\n\t}\r\n};\r\nexport const oneOf = (v,a,b,c,d,e) => v === a || v === b || v === c || v === d || v === e;\r\n\r\n// loader\r\nexport const uid = () => Math.round(performance.now()*100).toString(16);\r\n\r\n// db\r\nexport const rescue = (cb,alt) => { try { return cb(); } catch(e) { rescue.lastError = e; return alt; } };\r\nexport const fetchLocal = (k,alt) => rescue(()=>JSON.parse(localStorage.getItem(k))) || alt;\r\n// ifChange = (testCb,onChangeCb) => { let state; return (...args) => { const v = testCb(...args); if (v !== state) { onChangeCb(v); state = v; } return v; }; };\r\nexport const saveLocal = (k,v) => { localStorage.setItem(k, JSON.stringify(v)); };\r\n\r\n// app\r\nexport const hyphenate = s => null == s ? s : s.replace(/[^a-z0-9-]+/ig, '-').replace(/-*([A-Z])-*/g, (_,s)=>'-'+s.toLowerCase()).replace(/(^-+|-+$)/g, '');\r\nexport const selector = (query,parent=document.body) => parent instanceof Node ? parent.querySelector(query) : undefined;\r\nexport const selectorAll = (query,parent=document.body) => parent instanceof Node ? Array.from(parent.querySelectorAll(query)||[]) : [];\r\nexport const orEquals = (a,b,c,d,e) => null != a ? a : null != b ? b : null != c ? c : null != d ? d : null != e ? e : null;\r\nexport const val = function(input, value) {\r\n\tif (null == input) return;\r\n\tconst hasOptions = !!selector(input, 'option');\r\n\tif (1 === arguments.length) {\r\n\t\treturn hasOptions ?\r\n\t\t\tprop(selector('option[selected]', input), null, 'value') : // select > option[selected]\r\n\t\t\tget(undefined, input, 'value'); // input[password].value\r\n\t}\r\n\telse {\r\n\t\tif (hasOptions) {\r\n\t\t\tprop(selector('option[selected]', input), null, 'selected', undefined); // delete\r\n\t\t\tprop(selectorAll(`option[value]`, input)\r\n\t\t\t\t.find(option=>option.value===value), null, 'selected', 'selected');\r\n\t\t}\r\n\t\telse set(value, input, 'value');\r\n\t}\r\n}\r\nexport const tr = (k, o) => has(o, k) ? o[k] : o._;\r\nexport const nextTick = cb => setTimeout(cb, 0);\r\nexport const filter = (collection, test) =>\r\n\tArray.isArray(collection) ? collection.filter(test) :\r\n\tisObject(collection) ? Object.keys(collection)\r\n\t\t.reduce((o,k)=>{ if (test(collection[k])) o[k] = collection[k]; return o; },{}) :\r\n\ttest(collection) ? collection :\r\n\tundefined;\r\n\r\nexport const serializeForm = form =>\r\n\treduce({}, selectorAll('[name]', form), (acc,input) =>\r\n\t\tacc[prop(input, null, 'name')] = val(input));\r\n\r\nexport const request = (state, progressKey, method, url, data, redraw=false) => {\r\n\tset('load', state, progressKey);\r\n\tif (redraw) m.redraw();\r\n\tlet ok, fail;\r\n\tconst p = new Promise((res,rej)=>{\r\n\t\tok = value => {\r\n\t\t\tset('ok', state, progressKey);\r\n\t\t\tfire(res, value);\r\n\t\t\tif (redraw) nextTick(m.redraw);\r\n\t\t};\r\n\t\tfail = err => {\r\n\t\t\tset('fail', state, progressKey);\r\n\t\t\tfire(rej, err);\r\n\t\t\tif (redraw) nextTick(m.redraw);\r\n\t\t};\r\n\t});\r\n\ttry {\r\n\t\tconst xhr = new XMLHttpRequest();\r\n\t\txhr.open(method, url, true);\r\n\t\txhr.overrideMimeType('text/plain'); // avoid auto-parsing as xml\r\n\t\txhr.onreadystatechange = () => {\r\n\t\t\tif (4 !== xhr.readyState) return; // only proceed when request is complete\r\n\t\t\tconst data = JSON.parse(xhr.responseText);\r\n\t\t\tif (200 === xhr.status) ok(data);\r\n\t\t\telse fail(data);\r\n\t\t};\r\n\t\txhr.setRequestHeader('Content-Type', 'application/json');\r\n\t\txhr.send(JSON.stringify(data));\r\n\t}\r\n\tcatch(e) {\r\n\t\tfail(e);\r\n\t}\r\n\treturn p;\r\n};\r\nexport const rand = (min,max) => Math.floor(Math.random() * (max - min + 1) ) + min;\r\nexport const select = a => a[rand(0, a.length-1)];\r\nexport const delay = ms => new Promise(ok=>setTimeout(ok, ms));\r\nexport const trapEvent = cb => (...args) => {\r\n\tconst e = args.pop();\r\n\te.preventDefault();\r\n\te.stopPropagation();\r\n\tcb(...args, e);\r\n\treturn false;\r\n}\r\nexport const throttle = (ms,cb) => { // leading: false, trailing: true\r\n\tlet timer;\r\n\treturn (...args) => {\r\n\t\tif (null != timer) {\r\n\t\t\ttimer = clearTimeout(timer);\r\n\t\t}\r\n\t\ttimer = setTimeout(() => {\r\n\t\t\tcb(...args);\r\n\t\t\ttimer = null;\r\n\t\t}, ms);\r\n\t};\r\n};\r\nexport const trigger = (el, event, args) => { el.dispatchEvent(new Event(event, args)); };\r\nexport const activeIf = test => test ? '.active' : '';\r\nexport const onReady = cb => {\r\n\tconst fn = () => {\r\n\t\tif ('complete' === document.readyState) cb();\r\n\t};\r\n\tdocument.onreadystatechange = fn;\r\n\tfn(); // kick-start for hot-loading cases\r\n};\r\n\r\n// ex: sortByCols(['name', 'createdAt'], 1);\r\nexport const sortByCols = (k, dir=-1) => (a,b) => (k=> (null==k || get(null,a,k)===get(null,b,k)) ? 0 : get(null,a,k)<=get(null,b,k) ? dir : (dir*-1) )(k.find(_k=>get(null,a,_k)!==get(null,b,_k)));\r\nexport const clamp = (n,min,max) => Math.max(Math.min(n, max), min);\r\nexport const count = o => 'object' === typeof o ? Object.values(o).length : Array.isArray(o) ? o.length : 0;\r\nexport const fire = (fn, ...args) => { if (isFunction(fn)) return fn(...args); };\r\n\r\n// parsers\r\nexport const is = v => null != v;\r\nexport const NA = void 0;\r\nexport const upper = s => s.toUpperCase();\r\nexport const lower = s => s.toLowerCase();\r\nexport const sum = (sum, i) => sum+i;\r\nexport const isS = isString;\r\nexport const isA = a => Array.isArray(a);\r\nif (!is(Array.prototype.flat)) Array.prototype.flat = function() { return this.reduce((a,v)=>a.concat(v),[]); };","import * as Utils from './utils.js';\r\n\r\n// VNode is basically composable branches and traversal\r\nconst eachTag = function*(o) {\r\n\tif (!Utils.isObject(o)) return;\r\n\tfor (let k in o)\r\n\t\tif ('$'===k && 'object' !== typeof o.$) yield o.$;\r\n\t\telse if (!('$'===k[0] || '_'===k[0])) yield k;\r\n};\r\nexport let VNode = class VNode {\r\n\tconstructor(tag, attrs, ...children) {\r\n\t\tlet o;\r\n\t\tif (Utils.isFunction(Utils.get(null, tag, 'view'))) { this.$ = tag; o = this; }\r\n\t\telse { this[tag] = {}; o = this[tag]; }\r\n\t\tObject.assign(o, Utils.objectKeys(attrs).reduce((acc,k)=>{acc[k.replace(/^\\$?/, '$')]=attrs[k];return acc;},{}));\r\n\t\to._ = children;\r\n\t}\r\n};\r\nif (null == window.VNode) window.VNode = VNode; else VNode = window.VNode; // hot load (mostly)\r\n\r\nVNode.tag = o => {\r\n\tconst itr = eachTag(o), first = itr.next(), second = itr.next();\r\n\tif (second.done) return first.value;\r\n};\r\n// match group:          [1] id           [2] class           [3] attrName                        [5] attrValue\r\nconst RX_ATTRS = /\\s*(?:#([^\\s#\\.[\\]]+)|\\.([^\\s#\\.[\\]]+)|\\[\\s*([\\w:]+[^\\s=[\\]]*)?(?:\\s*=\\s*(['\"])?(.*?)\\4)?\\s*\\])\\s*/ig;\r\nVNode.attrs = function*(tag, o) {\r\n\tconst attrs = {};\r\n\ttag = tag.replace(RX_ATTRS, (...args) => {\r\n\t\tconst [/*match*/, id, cls, attrName, /*quot*/, attrValue, /*offset*/, /*str*/] = args;\r\n\t\tif (null != id)\r\n\t\t\tattrs.id = id; // last wins\r\n\t\telse if ('string' === typeof cls && '' !== cls.trim()) {\r\n\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', cls); // append space-delimited\r\n\t\t}\r\n\t\telse if (null != attrName)\r\n\t\t\tattrs[attrName] = undefined === attrValue ? null : attrValue; // merge object\r\n\t\treturn '';\r\n\t});\r\n\tif ('' === tag) tag = 'div'; // default\r\n\tyield tag; // first result is always the tag name\r\n\tif (Utils.isObject(o)) {\r\n\t\tfor (let k in o)\r\n\t\t\tif ('$class' === k) {\r\n\t\t\t\tif ('string' === typeof o.$class && '' !== o.$class.trim()) {\r\n\t\t\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', o.$class);\r\n\t\t\t\t}\r\n\t\t\t} else if ('$'===k[0] && k.length > 1)\r\n\t\t\t\tattrs[k.substr(1)] = o[k];\r\n\t}\r\n\tfor (let k in attrs)\r\n\t\tyield {\r\n\t\t\tk: k,\r\n\t\t\tev: 'on'===k.substr(0,2) ? k.substr(2) : undefined,\r\n\t\t\tv: attrs[k]\r\n\t\t};\r\n};\r\nVNode.children = function*(o) {\r\n\tif (null == o) return;\r\n\tif (Array.isArray(o)) {\r\n\t\tfor (const child of o)\r\n\t\t\tif (m.Component.isComponent(child)) yield child;\r\n\t\t\telse for (const _child of VNode.children(child))\r\n\t\t\t\tyield _child;\r\n\t}\r\n\telse if (Utils.isObject(o)) {\r\n\t\tfor (const tag of eachTag(o))\r\n\t\t\tyield Object.freeze({ [tag] : o[tag] });\r\n\t\tfor (const child of VNode.children(o._))\r\n\t\t\tyield child;\r\n\t}\r\n\telse if ('string' === typeof o || 'number' === typeof o)\r\n\t\tyield o;\r\n};\r\n\r\n// m() is basically reduced to an (optional) string parser\r\n// use it if it want, or just write the JXML directly to save cycles. your choice.\r\nlet m = (tag, ...args) => {\r\n\tconst attrs = {}, children = [];\r\n\tfor (let i=0,arg; args.length>0; i++) {\r\n\t\targ = args.shift();\r\n\t\tif (0 === i && Utils.isObject(arg) && !Array.isArray(arg) && !(arg instanceof VNode)) {\r\n\t\t\tObject.assign(attrs, arg); // attrs; merge\r\n\t\t}\r\n\t\telse if (Array.isArray(arg)) {\r\n\t\t\tchildren.splice(-1, 0, ...arg); // children; append\r\n\t\t}\r\n\t\telse {\r\n\t\t\tchildren.push(arg); // child; append\r\n\t\t}\r\n\t}\r\n\treturn new VNode(tag, attrs, ...children);\r\n};\r\nif (null == window.m) window.m = m; else m = window.m; // hot load (mostly)\r\n\r\nm.Component = class {\r\n\tconstructor(_static, attrs, ...children) {\r\n\t\tthis.dom = null;\r\n\t\tthis.static = _static;\r\n\t\tthis.attrs = attrs || {};\r\n\t\tthis.children = children || [];\r\n\t}\r\n}\r\nm.Component.isComponent = o =>  Utils.isFunction(Utils.get(null, o, '$', 'view'));\r\nm.Component.instance = (state, o) => { // wrap component in state\r\n\treturn {\r\n\t\tstate: state,\r\n\t\toninit(v) {\r\n\t\t\tif (true === state.inited) return;\r\n\t\t\tstate.inited = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oninit, v);\r\n\t\t},\r\n\t\toncreate(v) {\r\n\t\t\tif (true === state.created) return;\r\n\t\t\tstate.created = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oncreate, v);\r\n\t\t},\r\n\t\tonbeforeupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeupdate, v);\r\n\t\t},\r\n\t\tonupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onupdate, v);\r\n\t\t},\r\n\t\tview(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.view, v);\r\n\t\t},\r\n\t\tonbeforeremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeremove, v);\r\n\t\t},\t\t\t\r\n\t\tonremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\tconst r = Utils.call(o.onremove, v);\r\n\t\t\tfor (const key in state) {\r\n\t\t\t\tdelete state[key];\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\t};\r\n};\r\n// lifecycle methods\r\nfor (name of [\r\n\t'oninit', // on insert, append, or replace (instantiation), before dom element exists\r\n\t'view', // every render\r\n\t'oncreate', // just after init() is complete; dom element now exists\r\n\t'onbeforeupdate', // before diff happens on a node. return false to avoid checking (like manual dirty: false)\r\n\t'onupdate', // for pre-existing dom element, post-diff on each m.render() cycle\r\n\t'onbeforeremove', // before removeChild is invoked\r\n\t'onremove' // after removeChild is invoked\r\n]) {\r\n\tconst copyOfName = name;\r\n\tm.Component[copyOfName] = (inst, dom) => {\r\n\t\tif (!Utils.isFunction(inst.static[copyOfName])) return;\r\n\t\tif (null != dom) inst.dom = dom;\r\n\t\treturn inst.static[copyOfName](inst);\r\n\t};\r\n};\r\nm.root = null;\r\nconst internalAttrs = ['', 'key', 'dirty'];\r\nconst makeEl = (ns, vTag, v=null) =>\r\n\tnull == vTag ? document.createTextNode(v) :\r\n\tnull != ns[''] ? document.createElementNS(ns[''], vTag) :\r\n\tdocument.createElement(vTag);\r\nconst setEventListener = (el, event, cb) => {\r\n\tif (cb === Utils.data(el)[event]) return;\r\n\t// note: anon functions may have the same code, but will fail above check.\r\n\t//   therefore we re-bind because is no faster way to resolve the matter.\r\n\tel.removeEventListener(event, Utils.data(el)[event], true);\r\n\tel.addEventListener(event, Utils.data(el)[event] = cb, true);\r\n};\r\nconst xforms = { insertBefore: 0, appendChild:  1, recycleChild: 2, removeChild: 3 };\r\nlet abortRedraw;\r\n// basically graph theory: walk tree, apply graph transforms, where DOM == DAG\r\nconst applyVirtualDom = (domParent, vnode/* a.k.a. fragment*/, ns/*, cb*/) => {\r\n\tlet el, v, _v, vKey, vTag, attrsItr, attr, componentInstStack = [],\r\n\tfn, siblingIndex, changeIndex, foundKey, passover = new Set([]), i = -1;\r\n\tabortRedraw = false;\r\n\tconst applyComponentLifeCycle = (method, dom) => {\r\n\t\tif (null == componentInstStack || componentInstStack.length < 1) return;\r\n\t\tlet p = [];\r\n\t\tfor (const componentInst of componentInstStack) { // child-most first\r\n\t\t\tp.push(method(componentInst, dom));\r\n\t\t\t// notice: component lifecycle methods may return undefined or a Promise,\r\n\t\t\t//   which will stall the update but only for a particular component branch.\r\n\t\t\t//   its like dirty = false, but it can apply to indexed siblings too,\r\n\t\t\t//   as long as they dont move.\r\n\t\t}\r\n\t\treturn p; // array of return values\r\n\t};\r\n\tconst unwrapInitComponentStack = v => {\r\n\t\twhile (m.Component.isComponent(v)) {\r\n\t\t\tconst attrs = {}, children = [],\r\n\t\t\t\titr = VNode.attrs('', v);\r\n\t\t\titr.next().value; // discard tag\r\n\t\t\tfor (const attr of itr) {\r\n\t\t\t\tattrs[attr.k] = attr.v;\r\n\t\t\t}\r\n\t\t\tfor (const child of VNode.children(v)) {\r\n\t\t\t\tchildren.push(child);\r\n\t\t\t}\r\n\t\t\tconst componentInst = new m.Component(v.$, attrs, ...children);\r\n\t\t\tcomponentInstStack.unshift(componentInst); // child-most first\r\n\t\t\tif (applyComponentLifeCycle(m.Component.oninit).some(v=>false===v)) {\r\n\t\t\t\tabortRedraw = true;\r\n\t\t\t\tv = null;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tv = m.Component.view(componentInst); // may return another component\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn v;\r\n\t};\r\n\tconst despawn = (stack,cb) => {\r\n\t\tconst old = componentInstStack;\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onbeforeremove);\r\n\t\tcomponentInstStack = old;\r\n\t\tcb();\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onremove);\r\n\t\tcomponentInstStack = old;\r\n\t};\r\n\tconst replaceChild = (fn, el) => {\r\n\t\tfn(xforms.insertBefore, el);\r\n\t\t// TODO: if el has children, move them to new parent before removing el?\r\n\t\t//  preserves a parent whose tag changed but children did not\r\n\t\t//  ie. test with ul -> ol and same li children\r\n\t\tfn(xforms.removeChild, el);\r\n\t};\r\n\tconst applyXform = (xform, otherEl) => {\r\n\t\tswitch (xform) {\r\n\t\t\tcase xforms.insertBefore:\r\n\t\t\tcase xforms.appendChild:\r\n\t\t\t\tel = xforms.insertBefore === xform ? // either case will create empty tag\r\n\t\t\t\t\tdomParent.insertBefore(makeEl(ns, vTag, v), otherEl) :\r\n\t\t\t\t\tdomParent.appendChild (makeEl(ns, vTag, v));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.recycleChild:\r\n\t\t\t\tif (null != vTag) {\r\n\t\t\t\t\tif (el instanceof Text || (el.tagName||'').toUpperCase() !== vTag.toUpperCase()) // node type / tag name differ\r\n\t\t\t\t\t\treplaceChild(applyXform, el);\r\n\t\t\t\t\tconst existingAttrKeys = new Set([]);\r\n\t\t\t\t\tfor (attr of el.getAttributeNames()) {\r\n\t\t\t\t\t\texistingAttrKeys.add(attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of attrsItr) {\r\n\t\t\t\t\t\tif (!internalAttrs.includes(attr.k)) { // skip internal-only attrs\r\n\t\t\t\t\t\t\texistingAttrKeys.delete(attr.k.split(':').pop());\r\n\t\t\t\t\t\t\tif (null != attr.ev) setEventListener(el, attr.ev, attr.v);\r\n\t\t\t\t\t\t\telse if (Utils.prop(el, ns, attr.k) !== attr.v) // attr value differs\r\n\t\t\t\t\t\t\t\tUtils.prop(el, ns, attr.k, attr.v); // overwrite it\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of existingAttrKeys) {\r\n\t\t\t\t\t\tUtils.prop(el, ns, attr, undefined); // delete\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { // vnode is string\r\n\t\t\t\t\tif (el instanceof Text) {\r\n\t\t\t\t\t\tif (el.data !== _v) // text node differs\r\n\t\t\t\t\t\t\tel.data = _v; // replace text\r\n\t\t\t\t\t} else replaceChild(applyXform, el); // replace node\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.removeChild:\r\n\t\t\t\tdomParent.removeChild(otherEl);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\t// --- BEGIN LOOP ---\r\n\tvnode = unwrapInitComponentStack(vnode);\r\n\tlet componentInstStackOuterMarker = componentInstStack.length;\r\n\tif (abortRedraw) return;\r\n\tfor (v of VNode.children(vnode)) { // single-pass dom tree mutation to target vnode state\r\n\t\tcomponentInstStack.splice(componentInstStackOuterMarker);\r\n\t\ti++;\r\n\t\twhile (passover.has(i)) i++; // skip out-of-order dom nodes with keys, modified previously\r\n\t\tv = unwrapInitComponentStack(v);\r\n\t\tif (abortRedraw) return;\r\n\t\tif (Utils.isObject(v)) { vTag = VNode.tag(v); _v = v[vTag]; }\r\n\t\telse { vTag = null; _v = v; } // literal\r\n\t\tif (null != vTag) {\r\n\t\t\tattrsItr = VNode.attrs(vTag, _v); // pull attrs from tag string, if any\r\n\t\t\tns = Object.assign({}, ns);\r\n\t\t\tfor (const k in _v) {\r\n\t\t\t\tif ('$xmlns' === k)\r\n\t\t\t\tns[''] = _v[k];\r\n\t\t\t\telse if (/^\\$xmlns:/.test(k))\r\n\t\t\t\tns[k.substr(7)] = _v[k];\r\n\t\t\t}\r\n\t\t\tvTag = attrsItr.next().value; // post-processed tag name\r\n\t\t} else attrsItr = undefined;\r\n\t\tvKey = null != vTag ? Utils.get(null, _v, '$key') : null;\r\n\t\tchangeIndex = i; // unless we find an out-of-order key\r\n\t\tfoundKey = false;\r\n\t\t\r\n\t\tif (null != vKey) { // vnode has key; find its match among dom siblings\r\n\t\t\tif (Utils.data(domParent.childNodes[i]).key === vKey) foundKey = true; // current is matching\r\n\t\t\telse {\r\n\t\t\t\tsiblingIndex = domParent.childNodes.length;\r\n\t\t\t\twhile (!foundKey && siblingIndex-- > 0) {\r\n\t\t\t\t\tif (Utils.data(domParent.childNodes[siblingIndex]).key === vKey) {\r\n\t\t\t\t\t\tchangeIndex = siblingIndex;\r\n\t\t\t\t\t\tfoundKey = true;\r\n\t\t\t\t\t\ti--; // rewind for future vnode consideration, since no match here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!foundKey) { // no matching key among siblings\r\n\t\t\t\tapplyXform(xforms.insertBefore, domParent.childNodes[i]);\r\n\t\t\t\tUtils.data(domParent.childNodes[changeIndex]).key = vKey;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (null == domParent.childNodes[changeIndex]) {\r\n\t\t\tapplyXform(xforms.appendChild);\r\n\t\t}\r\n\t\tpassover.add(changeIndex); // mark node to avoid deletion\r\n\t\tif (foundKey && false === Utils.get(null, _v, '$dirty')) continue; // manual dirty; avoid node + descendant mutation\r\n\t\t// WARNING: manual dirty requires key. replacement of node or parent will delete key.\r\n\t\t\r\n\t\tel = domParent.childNodes[changeIndex];\r\n\t\tif (false === applyComponentLifeCycle(m.Component.onbeforeupdate)) continue;\r\n\t\tif (null == Utils.data(el).removing) { // target node is waiting for mutation\r\n\r\n\t\t\tlet differentComponentInst = [];\r\n\t\t\tconst existingStack = Utils.data(el).componentInstStack;\r\n\t\t\tif (null != existingStack) {\r\n\t\t\t\tfor (let i=existingStack.length-1; i>=0; i--) {\r\n\t\t\t\t\tif (null == componentInstStack[i] || existingStack[i].state !== componentInstStack[i].state) { // not the same component instance\r\n\t\t\t\t\t\tdifferentComponentInst.push(existingStack[i]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n\t\t\t}\t\r\n\t\t\tif (differentComponentInst.length>0) {\r\n\t\t\t\tdespawn(differentComponentInst, () => {\r\n\t\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tUtils.data(el).componentInstStack = componentInstStack;\r\n\t\t\t\r\n\t\t\tif (Utils.isObject(v)) {\r\n\t\t\t\tapplyVirtualDom(el, _v, ns/*, cb*/); // recurse (depth-first traversal)\r\n\t\t\t\tif (abortRedraw) return;\r\n\t\t\t}\r\n\t\t\tapplyComponentLifeCycle(m.Component.oncreate, el);\r\n\t\t\tapplyComponentLifeCycle(m.Component.onupdate, el);\r\n\t\t}\r\n\t}\r\n\tsiblingIndex = domParent.childNodes.length;\r\n\twhile (siblingIndex-- > 0) { // purge nodes w/o the mark\r\n\t\tel = domParent.childNodes[siblingIndex];\r\n\t\tcomponentInstStack = Utils.data(el).componentInstStack;\r\n\t\tif (!passover.has(siblingIndex) && null == Utils.data(el).removing)\r\n\t\t\tdespawn(componentInstStack, () => {\r\n\t\t\t\tapplyXform(xforms.removeChild, el);\r\n\t\t\t});\r\n\t}\r\n};\r\nlet timer, start, end;\r\nm.lastRenderTime = 0; // warn: browser limits reliability to +/-2ms\r\nconst _redraw = now => {\r\n\tm.renderCount++;\r\n\tstart = performance.now();\r\n\ttry {\r\n\t\tapplyVirtualDom(document.body, m.root);\r\n\t}\r\n\tcatch(e) {\r\n\t\tthrow e;\r\n\t}\r\n\tfinally {\r\n\t\tend = performance.now();\r\n\t\tm.lastRenderTime = end - start;\r\n\t\ttimer = null;\r\n\t}\r\n};\r\nm.renderCount = 0;\r\nm.redraw = () => {\r\n\tif (null != timer) return;\r\n\ttimer = 1;\r\n\t_redraw();\r\n};\r\n\r\nm.untrusted = v => {\r\n\tif ('string' === typeof v) return v;\r\n\telse if ('number' === typeof v) return ''+v;\r\n\telse {\r\n\t\tconsole.error('Malicious value', v);\r\n\t\treturn '';\r\n\t}\r\n};\r\n\r\nexport default m;"],"names":["isObject","o","objectKeys","Object","keys","resolve","path","length","has","key","hasOwnProperty","call","shift","get","alt","r","isStringEmpty","s","joinStringIfNotEmpty","a","delim","b","isFunction","fn","paramCount","data","l","el","Proxy","set","k","undefined","v","flush","WeakMap","args","notNullOrEmptyElse","defaultValue","prop","ns","arguments","prefix","split","reverse","getAttribute","getAttributeNS","removeAttribute","removeAttributeNS","setAttribute","setAttributeNS","Array","prototype","flat","this","reduce","concat","eachTag","Utils.isObject","$","VNode","[object Object]","tag","attrs","children","Utils.isFunction","Utils.get","assign","Utils.objectKeys","acc","replace","_","window","itr","first","next","second","done","value","id","cls","attrName","attrValue","trim","class","Utils.joinStringIfNotEmpty","$class","substr","ev","isArray","child","m","Component","isComponent","_child","freeze","arg","i","splice","push","_static","dom","static","instance","state","inited","Utils.call","oninit","created","oncreate","onbeforeupdate","onupdate","view","onbeforeremove","onremove","name","copyOfName","inst","m$1","root","internalAttrs","makeEl","vTag","document","createTextNode","createElementNS","createElement","setEventListener","event","cb","Utils.data","removeEventListener","addEventListener","xforms","insertBefore","appendChild","recycleChild","removeChild","abortRedraw","applyVirtualDom","domParent","vnode","_v","vKey","attrsItr","attr","siblingIndex","changeIndex","foundKey","componentInstStack","passover","Set","applyComponentLifeCycle","method","p","componentInst","unwrapInitComponentStack","unshift","some","despawn","stack","old","replaceChild","applyXform","xform","otherEl","Text","tagName","toUpperCase","existingAttrKeys","getAttributeNames","add","includes","delete","pop","Utils.prop","componentInstStackOuterMarker","test","childNodes","removing","differentComponentInst","existingStack","timer","start","end","lastRenderTime","_redraw","now","renderCount","performance","body","e","redraw","untrusted","console","error"],"mappings":"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"}