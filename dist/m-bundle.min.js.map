{"version":3,"file":"m-bundle.min.js","sources":["../src/utils.js","../src/m.js"],"sourcesContent":["// m, etc.\r\nexport const isEmptyArray = a => Array.isArray(a) && a.length < 1;\r\nexport const isObject = o => null != o && 'object' === typeof o; // null is #NotOurObject\r\nexport const isEmptyObject = o => isEmptyArray(Object.keys(o));\r\nexport const toArray = a => isObject(a) && a.length >= 0 ? Array.from(a) : [];\r\nexport const reduce = (initial, a, cb) => toArray(a).reduce((acc,x)=>{ cb(acc,x); return acc; }, initial);\r\nexport const objectKeys = o => isObject(o) ? Object.keys(o) : [];\r\nexport const pick = (o, ...keys) => reduce({}, objectKeys(o).filter(k=> keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const omit = (o, ...keys) => reduce({}, objectKeys(o).filter(k=>!keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const setAdd = (s, ...vals) => vals.forEach(v=>s.add(v));\r\nexport const resolve = (o, ...path) => {\r\n\t// TODO: could optimize this to generate less GC with pattern matching\r\n\t// TODO: remove anything that creates unnecessary arrays, especially use pattern matching,\r\n\t// TODO: and stop returning empty {} or [] for convenience sake. check it on iterate, instead.\r\n\tif (!isObject(o) || path.length < 1)\r\n\t\treturn { has: isObject(o) && path.length < 1, o: o, key: path[0] };\r\n\telse if (1 === path.length)\r\n\t\treturn { has: Object.hasOwnProperty.call(o, path[0]), o: o, key: path[0] };\r\n\telse return resolve(o[path.shift()], ...path);\r\n};\r\nexport const has = (o, ...path) => undefined === path[0] ? false : resolve(o, ...path).has;\r\nexport const get = (alt, o, ...path) => {\r\n\tconst r = resolve(o, ...path);\r\n\treturn r.o && r.o[r.key] || alt;\r\n};\r\nexport const set = (val, o, ...path) => {\r\n\tconst key = path.pop(), r = resolve(o, ...path);\r\n\tif (r.has) return (undefined === r.key ? r.o : r.o[r.key])[key] = val;\r\n};\r\nexport const isString = s => 'string' === typeof s;\r\nexport const isStringEmpty = s => null == s || '' === s;\r\nexport const joinStringIfNotEmpty = (a,delim,b) => isStringEmpty(a) ? b : a + delim + b;\r\nexport const isFunction = (fn,paramCount) => 'function' === typeof fn && (null == paramCount || fn.length === paramCount);\r\nexport const map = (a,cb) => null == a ? undefined : Array.isArray(a) ? a.map(cb) : isObject(a) ? Object.keys(a).map(k=>cb(a[k],k)) : a;\r\nexport const data = (()=>{\r\n\tlet l, s;\r\n\tconst r = el => new Proxy(\r\n\t\tnull != el && (s.has(el) ? s.get(el) : (l={},s.set(el,l),l)), {\r\n\t\tget: (o,k) => o ? o[k] : undefined,\r\n\t\tset: (o,k,v) => o ? (o[k] = v) : undefined,\r\n\t})\r\n\tr.flush = () => { s = new WeakMap() };\r\n\tr.flush();\r\n\treturn r;\r\n})();\r\nexport const then2 = (p,cb) => p.then(v=>cb(null, v), e=>cb(e));\r\nexport const call = (fn, ...args) => { if ( isFunction(fn)) return fn(...args) };\r\nexport const toStringValue = v => null == v ? '' : isObject(v) ? JSON.stringify(v) : v;\r\nexport const notNullOrEmptyElse = (v, defaultValue) => null != v && '' !== v ? v : defaultValue;\r\nexport const prop = function(el, ns, k, v) {\r\n\tif (null == el || arguments.length < 3) return;\r\n\tconst [key,prefix] = k.split(':').reverse();\r\n\tif (3 === arguments.length) {\r\n\t\tif (null == prefix) return notNullOrEmptyElse(el.getAttribute(key), undefined);\r\n\t\telse return notNullOrEmptyElse(el.getAttributeNS(ns[key], key), undefined);\r\n\t}\r\n\telse if (undefined === v) {\r\n\t\tif (null == prefix) el.removeAttribute(key);\r\n\t\telse el.removeAttributeNS(ns[key], key);\r\n\t}\r\n\telse {\r\n\t\tif (null == prefix) el.setAttribute(key, null == v ? '' : v);\r\n\t\telse {\r\n\t\t\tel.setAttributeNS(ns[key], key, null == v ? '' : v);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// loader\r\nexport const getUid = () => Math.round(performance.now()*100).toString(16);\r\n\r\n// db\r\nexport const rescue = (cb,alt) => { try { return cb(); } catch(e) { rescue.lastError = e; return alt; } };\r\nexport const fetchLocal = (k,alt) => rescue(()=>JSON.parse(localStorage.getItem(k))) || alt;\r\n// ifChange = (testCb,onChangeCb) => { let state; return (...args) => { const v = testCb(...args); if (v !== state) { onChangeCb(v); state = v; } return v; }; };\r\nexport const saveLocal = (k,v) => { localStorage.setItem(k, JSON.stringify(v)); };\r\n\r\n// app\r\nexport const hyphenate = s => null == s ? s : s.replace(/[^a-z0-9-]+/ig, '-').replace(/-*([A-Z])-*/g, (_,s)=>'-'+s.toLowerCase()).replace(/(^-+|-+$)/g, '');\r\nexport const selector = (query,parent=document.body) => parent instanceof Node ? parent.querySelector(query) : undefined;\r\nexport const selectorAll = (query,parent=document.body) => parent instanceof Node ? Array.from(parent.querySelectorAll(query)||[]) : [];\r\nexport const orEquals = (a,b,c,d,e) => null != a ? a : null != b ? b : null != c ? c : null != d ? d : null != e ? e : null;\r\nexport const val = function(input, value) {\r\n\tif (null == input) return;\r\n\tconst hasOptions = !!selector(input, 'option');\r\n\tif (1 === arguments.length) {\r\n\t\treturn hasOptions ?\r\n\t\t\tprop(selector('option[selected]', input), null, 'value') : // select > option[selected]\r\n\t\t\tget(undefined, input, 'value'); // input[password].value\r\n\t}\r\n\telse {\r\n\t\tif (hasOptions) {\r\n\t\t\tprop(selector('option[selected]', input), null, 'selected', undefined); // delete\r\n\t\t\tprop(selectorAll(`option[value]`, input)\r\n\t\t\t\t.find(option=>option.value===value), null, 'selected', 'selected');\r\n\t\t}\r\n\t\telse set(value, input, 'value');\r\n\t}\r\n}\r\nexport const serializeForm = form =>\r\n\treduce({}, selectorAll('[name]', form), (acc,input) =>\r\n\t\tacc[prop(input, null, 'name')] = val(input));\r\nexport const request = (method, url, data) => {\r\n\tlet ok, fail;\r\n\tconst p = new Promise((a,b)=>{ok=a;fail=b});\r\n\ttry {\r\n\t\tconst xhr = new XMLHttpRequest();\r\n\t\txhr.open(method, url, true);\r\n\t\txhr.onreadystatechange = () => {\r\n\t\t\tif (4 !== xhr.readyState) return; // only proceed when request is complete\r\n\t\t\tconst data = rescue(()=>JSON.parse(xhr.responseText));\r\n\t\t\tif (200 === xhr.status) ok(data); else fail(data);\r\n\t\t};\r\n\t\txhr.setRequestHeader('Content-Type', 'application/json');\r\n\t\txhr.send(JSON.stringify(data));\r\n\t}\r\n\tcatch(e) {\r\n\t\tfail(e);\r\n\t}\r\n\treturn p;\r\n};\r\nexport const rand = (min,max) => Math.floor(Math.random() * (max - min + 1) ) + min;\r\nexport const select = a => a[rand(0, a.length-1)];\r\nexport const delay = ms => new Promise(ok=>setTimeout(ok, ms));\r\nexport const trapEvent = cb => (...args) => {\r\n\tconst e = args.pop();\r\n\te.preventDefault();\r\n\te.stopPropagation();\r\n\tcb(...args, e);\r\n\treturn false;\r\n}\r\nexport const throttle = (ms,cb) => { // leading: false, trailing: true\r\n\tlet timer;\r\n\treturn (...args) => {\r\n\t\tif (null != timer) {\r\n\t\t\ttimer = clearTimeout(timer);\r\n\t\t}\r\n\t\ttimer = setTimeout(() => {\r\n\t\t\tcb(...args);\r\n\t\t\ttimer = null;\r\n\t\t}, ms);\r\n\t};\r\n};\r\nexport const trigger = (el, event, args) => { el.dispatchEvent(new Event(event, args)); };\r\nexport const activeIf = test => test ? '.active' : '';\r\nexport const onReady = cb => {\r\n\tconst fn = () => {\r\n\t\tif ('complete' === document.readyState) cb();\r\n\t};\r\n\tdocument.onreadystatechange = fn;\r\n\tfn(); // kick-start for hot-loading cases\r\n};\r\n\r\nexport default Utils;","import * as Utils from './utils.js';\r\n\r\n/*\r\n\tPug markup\r\n\r\n\t!doctype html\r\n\thtml\r\n\t\tbody\r\n\t\t\tp#id.cls[attr=val]\r\n\t\t\t\thello\r\n\t\t\t\tstrong how\r\n\t\t\t\tare you?\r\n\r\n\tbecomes:\r\n\tJXML ([lossless] Javascript XML)\r\n\r\n\t{\r\n\t\t\"!doctype\": { $html: null },\r\n\t\thtml: { body: {\r\n\t\t\tp: { $id: 'id', $class: 'cls', $attr: 'val', _: [\r\n\t\t\t\t'hello',\r\n\t\t\t\t{ strong: { _: 'how' } },\r\n\t\t\t\t'are you?'\r\n\t\t\t]}\r\n\t\t}}\r\n\t}\r\n*/\r\n\r\n// dom, attrs, children\r\n// notice: component has state, vnode does not\r\n// notice: therefore only a component instance needs to track state\r\n// todo: concept of soft-delete: removes from dom but doesn't lose state. then state becomes useful again\r\n\r\n// vnode = [{ tag: null }, ...] === <tag/>\r\n// vnode = [{ tag: { $attr: 'val' } }, ...] === <tag attr=\"val\"/>\r\n// vnode = [{ tag: { $attr: 'val', _: VNODE } }, ...]\r\n//     ex: [{ tag: { $attr: 'val', _: ['hello ', { strong: { _: 'every' }}, ' one' ] } }, ...] === <tag attr=\"val\">hello <strong>every</strong> one</tag>\r\n// notice: when printing for brevity, the arrays are optional; replacing with `anything` is the same as `[anything]`\r\n//     ex:  { tag: { $attr: 'val', _: 'hello world' } } === <tag attr=\"val\">hello world</tag>\r\n// notice: likewise, since attrs are namespaced by $ prefix, children can be implicit as well,\r\n//         but only if their tag names are unique\r\n//     ex:  { a: { $b: 'c', d: { e: { _: 'f' }}}} === <a b=\"c\"><d><e>f</e></d></a>\r\n\r\n// see also: https://www.freeformatter.com/xml-to-json-converter.html\r\n// note: set \"Prefix attributes with:\" to \"$\" and \"#text property name:\" to \"_\"\r\n\r\n// VNode is basically composable branches and traversal\r\nconst eachTag = function*(o) {\r\n\tif (!Utils.isObject(o)) return;\r\n\tfor (let k in o)\r\n\t\tif ('$'===k && 'object' !== typeof o.$) yield o.$;\r\n\t\telse if (!('$'===k[0] || '_'===k[0])) yield k;\r\n};\r\n\r\nexport let VNode = class VNode {\r\n\tconstructor(tag, attrs, ...children) {\r\n\t\tlet o;\r\n\t\tif (Utils.isFunction(Utils.get(null, tag, 'view'))) { this.$ = tag; o = this; }\r\n\t\telse { this[tag] = {}; o = this[tag]; }\r\n\t\tObject.assign(o, Utils.objectKeys(attrs).reduce((acc,k)=>{acc[k.replace(/^\\$?/, '$')]=attrs[k];return acc;},{}));\r\n\t\to._ = children;\r\n\t}\r\n};\r\nif (null == window.VNode) window.VNode = VNode; else VNode = window.VNode; // hot load (mostly)\r\n\r\nVNode.tag = o => {\r\n\tconst itr = eachTag(o), first = itr.next(), second = itr.next();\r\n\tif (second.done) return first.value;\r\n};\r\n// match group:          [1] id           [2] class           [3] attrName                        [5] attrValue\r\nconst RX_ATTRS = /\\s*(?:#([^\\s#\\.[\\]]+)|\\.([^\\s#\\.[\\]]+)|\\[\\s*([\\w:]+[^\\s=[\\]]*)?(?:\\s*=\\s*(['\"])?(.*?)\\4)?\\s*\\])\\s*/ig;\r\nVNode.attrs = function*(tag, o) {\r\n\tconst attrs = {};\r\n\ttag = tag.replace(RX_ATTRS, (...args) => {\r\n\t\tconst [/*match*/, id, cls, attrName, /*quot*/, attrValue, /*offset*/, /*str*/] = args;\r\n\t\tif (null != id)\r\n\t\t\tattrs.id = id; // last wins\r\n\t\telse if ('string' === typeof cls && '' !== cls.trim()) {\r\n\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', cls); // append space-delimited\r\n\t\t}\r\n\t\telse if (null != attrName)\r\n\t\t\tattrs[attrName] = undefined === attrValue ? null : attrValue; // merge object\r\n\t\treturn '';\r\n\t});\r\n\tif ('' === tag) tag = 'div'; // default\r\n\tyield tag; // first result is always the tag name\r\n\tif (Utils.isObject(o)) {\r\n\t\tfor (let k in o)\r\n\t\t\tif ('$class' === k) {\r\n\t\t\t\tif ('string' === typeof o.$class && '' !== o.$class.trim()) {\r\n\t\t\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', o.$class);\r\n\t\t\t\t}\r\n\t\t\t} else if ('$'===k[0] && k.length > 1)\r\n\t\t\t\tattrs[k.substr(1)] = o[k];\r\n\t}\r\n\tfor (let k in attrs)\r\n\t\tyield {\r\n\t\t\tk: k,\r\n\t\t\tev: 'on'===k.substr(0,2) ? k.substr(2) : undefined,\r\n\t\t\tv: attrs[k]\r\n\t\t};\r\n};\r\nVNode.children = function*(o) {\r\n\tif (null == o) return;\r\n\tif (Array.isArray(o)) {\r\n\t\tfor (const child of o)\r\n\t\t\tif (m.Component.isComponent(child)) yield child;\r\n\t\t\telse for (const _child of VNode.children(child))\r\n\t\t\t\tyield _child;\r\n\t}\r\n\telse if (Utils.isObject(o)) {\r\n\t\tfor (const tag of eachTag(o))\r\n\t\t\tyield Object.freeze({ [tag] : o[tag] });\r\n\t\tfor (const child of VNode.children(o._))\r\n\t\t\tyield child;\r\n\t}\r\n\telse if ('string' === typeof o || 'number' === typeof o)\r\n\t\tyield o;\r\n};\r\n\r\n\r\n// m() is basically reduced to an (optional) string parser\r\n// use it if it want, or just write the JXML directly to save cycles. your choice.\r\nlet m = (tag, ...args) => {\r\n\tconst attrs = {}, children = [];\r\n\tfor (let i=0,arg; args.length>0; i++) {\r\n\t\targ = args.shift();\r\n\t\tif (0 === i && Utils.isObject(arg) && !Array.isArray(arg) && !(arg instanceof VNode)) {\r\n\t\t\tObject.assign(attrs, arg); // attrs; merge\r\n\t\t}\r\n\t\telse if (Array.isArray(arg)) {\r\n\t\t\tchildren.splice(-1, 0, ...arg); // children; append\r\n\t\t}\r\n\t\telse {\r\n\t\t\tchildren.push(arg); // child; append\r\n\t\t}\r\n\t}\r\n\treturn new VNode(tag, attrs, ...children);\r\n};\r\nif (null == window.m) window.m = m; else m = window.m; // hot load (mostly)\r\n\r\nm.Component = class {\r\n\tconstructor(_static, attrs, ...children) {\r\n\t\tthis.dom = null;\r\n\t\tthis.static = _static;\r\n\t\tthis.attrs = attrs || {};\r\n\t\tthis.children = children || [];\r\n\t}\r\n}\r\nm.Component.isComponent = o =>  Utils.isFunction(Utils.get(null, o, '$', 'view'));\r\nm.Component.instance = (state, o) => { // wrap component in state\r\n\treturn {\r\n\t\tstate: state,\r\n\t\toninit(v) {\r\n\t\t\tif (true === state.inited) return;\r\n\t\t\tstate.inited = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oninit, v);\r\n\t\t},\r\n\t\toncreate(v) {\r\n\t\t\tif (true === state.created) return;\r\n\t\t\tstate.created = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oncreate, v);\r\n\t\t},\r\n\t\tonbeforeupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeupdate, v);\r\n\t\t},\r\n\t\tonupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onupdate, v);\r\n\t\t},\r\n\t\tview(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.view, v);\r\n\t\t},\r\n\t\tonbeforeremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeremove, v);\r\n\t\t},\t\t\t\r\n\t\tonremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\tconst r = Utils.call(o.onremove, v);\r\n\t\t\tfor (const key in state) {\r\n\t\t\t\tdelete state[key];\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\t};\r\n};\r\n// lifecycle methods\r\nfor (name of [\r\n\t'oninit', // on insert, append, or replace (instantiation), before dom element exists\r\n\t'view', // every render\r\n\t'oncreate', // just after init() is complete; dom element now exists\r\n\t'onbeforeupdate', // before diff happens on a node. return false to avoid checking (like manual dirty: false)\r\n\t'onupdate', // for pre-existing dom element, post-diff on each m.render() cycle\r\n\t'onbeforeremove', // before removeChild is invoked\r\n\t'onremove' // after removeChild is invoked\r\n]) {\r\n\tconst copyOfName = name;\r\n\tm.Component[copyOfName] = (inst, dom) => {\r\n\t\tif (!Utils.isFunction(inst.static[copyOfName])) return;\r\n\t\tif (null != dom) inst.dom = dom;\r\n\t\treturn inst.static[copyOfName](inst);\r\n\t};\r\n};\r\nm.root = null;\r\nconst internalAttrs = ['', 'key', 'dirty'];\r\nconst makeEl = (ns, vTag, v=null) =>\r\n\tnull == vTag ? document.createTextNode(v) :\r\n\tnull != ns[''] ? document.createElementNS(ns[''], vTag) :\r\n\tdocument.createElement(vTag);\r\nconst setEventListener = (el, event, cb) => {\r\n\tif (cb === Utils.data(el)[event]) return;\r\n\t// note: anon functions may have the same code, but will fail above check.\r\n\t//   therefore we re-bind because is no faster way to resolve the matter.\r\n\tel.removeEventListener(event, Utils.data(el)[event], true);\r\n\tel.addEventListener(event, Utils.data(el)[event] = cb, true);\r\n};\r\nconst xforms = { insertBefore: 0, appendChild:  1, recycleChild: 2, removeChild: 3 };\r\nlet abortRedraw;\r\n// basically graph theory: walk tree, apply graph transforms, where DOM == DAG\r\nconst applyVirtualDom = (domParent, vnode/* a.k.a. fragment*/, ns/*, cb*/) => {\r\n\tlet el, v, _v, vKey, vTag, attrsItr, attr, componentInstStack = [],\r\n\tfn, siblingIndex, changeIndex, foundKey, passover = new Set([]), i = -1;\r\n\tabortRedraw = false;\r\n\tconst applyComponentLifeCycle = (method, dom) => {\r\n\t\tif (null == componentInstStack || componentInstStack.length < 1) return;\r\n\t\tlet p = [];\r\n\t\tfor (const componentInst of componentInstStack) { // child-most first\r\n\t\t\tp.push(method(componentInst, dom));\r\n\t\t\t// notice: component lifecycle methods may return undefined or a Promise,\r\n\t\t\t//   which will stall the update but only for a particular component branch.\r\n\t\t\t//   its like dirty = false, but it can apply to indexed siblings too,\r\n\t\t\t//   as long as they dont move.\r\n\t\t}\r\n\t\treturn p; // array of return values\r\n\t};\r\n\tconst unwrapInitComponentStack = v => {\r\n\t\twhile (m.Component.isComponent(v)) {\r\n\t\t\tconst attrs = {}, children = [],\r\n\t\t\t\titr = VNode.attrs('', v);\r\n\t\t\titr.next().value; // discard tag\r\n\t\t\tfor (const attr of itr) {\r\n\t\t\t\tattrs[attr.k] = attr.v;\r\n\t\t\t}\r\n\t\t\tfor (const child of VNode.children(v)) {\r\n\t\t\t\tchildren.push(child);\r\n\t\t\t}\r\n\t\t\tconst componentInst = new m.Component(v.$, attrs, ...children);\r\n\t\t\tcomponentInstStack.unshift(componentInst); // child-most first\r\n\t\t\tif (applyComponentLifeCycle(m.Component.oninit).some(v=>false===v)) {\r\n\t\t\t\tabortRedraw = true;\r\n\t\t\t\tv = null;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tv = m.Component.view(componentInst); // may return another component\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn v;\r\n\t};\r\n\tconst despawn = (stack,cb) => {\r\n\t\tconst old = componentInstStack;\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onbeforeremove);\r\n\t\tcomponentInstStack = old;\r\n\t\tcb();\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onremove);\r\n\t\tcomponentInstStack = old;\r\n\t};\r\n\tconst replaceChild = (fn, el) => {\r\n\t\tfn(xforms.insertBefore, el);\r\n\t\t// TODO: if el has children, move them to new parent before removing el?\r\n\t\t//  preserves a parent whose tag changed but children did not\r\n\t\t//  ie. test with ul -> ol and same li children\r\n\t\tfn(xforms.removeChild, el);\r\n\t};\r\n\tconst applyXform = (xform, otherEl) => {\r\n\t\tswitch (xform) {\r\n\t\t\tcase xforms.insertBefore:\r\n\t\t\tcase xforms.appendChild:\r\n\t\t\t\tel = xforms.insertBefore === xform ? // either case will create empty tag\r\n\t\t\t\t\tdomParent.insertBefore(makeEl(ns, vTag, v), otherEl) :\r\n\t\t\t\t\tdomParent.appendChild (makeEl(ns, vTag, v));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.recycleChild:\r\n\t\t\t\tif (null != vTag) {\r\n\t\t\t\t\tif (el instanceof Text || (el.tagName||'').toUpperCase() !== vTag.toUpperCase()) // node type / tag name differ\r\n\t\t\t\t\t\treplaceChild(applyXform, el);\r\n\t\t\t\t\tconst existingAttrKeys = new Set([]);\r\n\t\t\t\t\tfor (attr of el.getAttributeNames()) {\r\n\t\t\t\t\t\texistingAttrKeys.add(attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of attrsItr) {\r\n\t\t\t\t\t\tif (!internalAttrs.includes(attr.k)) { // skip internal-only attrs\r\n\t\t\t\t\t\t\texistingAttrKeys.delete(attr.k.split(':').pop());\r\n\t\t\t\t\t\t\tif (null != attr.ev) setEventListener(el, attr.ev, attr.v);\r\n\t\t\t\t\t\t\telse if (Utils.prop(el, ns, attr.k) !== attr.v) // attr value differs\r\n\t\t\t\t\t\t\t\tUtils.prop(el, ns, attr.k, attr.v); // overwrite it\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of existingAttrKeys) {\r\n\t\t\t\t\t\tUtils.prop(el, ns, attr, undefined); // delete\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { // vnode is string\r\n\t\t\t\t\tif (el instanceof Text) {\r\n\t\t\t\t\t\tif (el.data !== _v) // text node differs\r\n\t\t\t\t\t\t\tel.data = _v; // replace text\r\n\t\t\t\t\t} else replaceChild(applyXform, el); // replace node\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.removeChild:\r\n\t\t\t\tdomParent.removeChild(otherEl);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t// --- BEGIN LOOP ---\r\n\tvnode = unwrapInitComponentStack(vnode);\r\n\tlet componentInstStackOuterMarker = componentInstStack.length;\r\n\tif (abortRedraw) return;\r\n\tfor (v of VNode.children(vnode)) { // single-pass dom tree mutation to target vnode state\r\n\t\tcomponentInstStack.splice(componentInstStackOuterMarker);\r\n\t\ti++;\r\n\t\twhile (passover.has(i)) i++; // skip out-of-order dom nodes with keys, modified previously\r\n\t\tv = unwrapInitComponentStack(v);\r\n\t\tif (abortRedraw) return;\r\n\t\tif (Utils.isObject(v)) { vTag = VNode.tag(v); _v = v[vTag]; }\r\n\t\telse { vTag = null; _v = v; } // literal\r\n\t\tif (null != vTag) {\r\n\t\t\tattrsItr = VNode.attrs(vTag, _v); // pull attrs from tag string, if any\r\n\t\t\tns = Object.assign({}, ns);\r\n\t\t\tfor (const k in _v) {\r\n\t\t\t\tif ('$xmlns' === k)\r\n\t\t\t\tns[''] = _v[k];\r\n\t\t\t\telse if (/^\\$xmlns:/.test(k))\r\n\t\t\t\tns[k.substr(7)] = _v[k];\r\n\t\t\t}\r\n\t\t\tvTag = attrsItr.next().value; // post-processed tag name\r\n\t\t} else attrsItr = undefined;\r\n\t\tvKey = null != vTag ? Utils.get(null, _v, '$key') : null;\r\n\t\tchangeIndex = i; // unless we find an out-of-order key\r\n\t\tfoundKey = false;\r\n\t\t\r\n\t\tif (null != vKey) { // vnode has key; find its match among dom siblings\r\n\t\t\tif (Utils.data(domParent.childNodes[i]).key === vKey) foundKey = true; // current is matching\r\n\t\t\telse {\r\n\t\t\t\tsiblingIndex = domParent.childNodes.length;\r\n\t\t\t\twhile (!foundKey && siblingIndex-- > 0) {\r\n\t\t\t\t\tif (Utils.data(domParent.childNodes[siblingIndex]).key === vKey) {\r\n\t\t\t\t\t\tchangeIndex = siblingIndex;\r\n\t\t\t\t\t\tfoundKey = true;\r\n\t\t\t\t\t\ti--; // rewind for future vnode consideration, since no match here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!foundKey) { // no matching key among siblings\r\n\t\t\t\tapplyXform(xforms.insertBefore, domParent.childNodes[i]);\r\n\t\t\t\tUtils.data(domParent.childNodes[changeIndex]).key = vKey;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (null == domParent.childNodes[changeIndex]) {\r\n\t\t\tapplyXform(xforms.appendChild);\r\n\t\t}\r\n\t\tpassover.add(changeIndex); // mark node to avoid deletion\r\n\t\tif (foundKey && false === Utils.get(null, _v, '$dirty')) continue; // manual dirty; avoid node + descendant mutation\r\n\t\t// WARNING: manual dirty requires key. replacement of node or parent will delete key.\r\n\t\t\r\n\t\tel = domParent.childNodes[changeIndex];\r\n\t\tif (false === applyComponentLifeCycle(m.Component.onbeforeupdate)) continue;\r\n\t\tif (null == Utils.data(el).removing) { // target node is waiting for mutation\r\n\r\n\t\t\tlet differentComponentInst = [];\r\n\t\t\tconst existingStack = Utils.data(el).componentInstStack;\r\n\t\t\tif (null != existingStack) {\r\n\t\t\t\tfor (let i=existingStack.length-1; i>=0; i--) {\r\n\t\t\t\t\tif (null == componentInstStack[i] || existingStack[i].state !== componentInstStack[i].state) { // not the same component instance\r\n\t\t\t\t\t\tdifferentComponentInst.push(existingStack[i]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n\t\t\t}\t\r\n\t\t\tif (differentComponentInst.length>0) {\r\n\t\t\t\tdespawn(differentComponentInst, () => {\r\n\t\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tUtils.data(el).componentInstStack = componentInstStack;\r\n\t\t\t\r\n\t\t\tif (Utils.isObject(v)) {\r\n\t\t\t\tapplyVirtualDom(el, _v, ns/*, cb*/); // recurse (depth-first traversal)\r\n\t\t\t\tif (abortRedraw) return;\r\n\t\t\t}\r\n\t\t\tapplyComponentLifeCycle(m.Component.oncreate, el);\r\n\t\t\tapplyComponentLifeCycle(m.Component.onupdate, el);\r\n\t\t}\r\n\t}\r\n\tsiblingIndex = domParent.childNodes.length;\r\n\twhile (siblingIndex-- > 0) { // purge nodes w/o the mark\r\n\t\tel = domParent.childNodes[siblingIndex];\r\n\t\tcomponentInstStack = Utils.data(el).componentInstStack;\r\n\t\tif (!passover.has(siblingIndex) && null == Utils.data(el).removing)\r\n\t\t\tdespawn(componentInstStack, () => {\r\n\t\t\t\tapplyXform(xforms.removeChild, el);\r\n\t\t\t});\r\n\t}\r\n};\r\nlet timer, start, end;\r\nm.lastRenderTime = 0; // warn: browser limits reliability to +/-2ms\r\nconst _redraw = now => {\r\n\tm.renderCount++;\r\n\tstart = performance.now();\r\n\ttry {\r\n\t\tapplyVirtualDom(document.body, m.root);\r\n\t}\r\n\tcatch(e) {\r\n\t\tthrow e;\r\n\t}\r\n\tfinally {\r\n\t\tend = performance.now();\r\n\t\tm.lastRenderTime = end - start;\r\n\t\ttimer = null;\r\n\t}\r\n};\r\nm.renderCount = 0;\r\nm.redraw = () => {\r\n\tif (null != timer) {\r\n\t\tconsole.warn('already redrawing...');\r\n\t\treturn;\r\n\t}\r\n\r\n\ttimer = 1;\r\n\t_redraw();\r\n\t// timer = requestAnimationFrame(_redraw);\r\n};\r\n\r\nexport default m;"],"names":["isObject","o","objectKeys","Object","keys","resolve","path","length","has","key","hasOwnProperty","call","shift","get","alt","r","isStringEmpty","s","joinStringIfNotEmpty","a","delim","b","isFunction","fn","paramCount","data","l","el","Proxy","set","k","undefined","v","flush","WeakMap","args","notNullOrEmptyElse","defaultValue","prop","ns","arguments","prefix","split","reverse","getAttribute","getAttributeNS","removeAttribute","removeAttributeNS","setAttribute","setAttributeNS","eachTag","Utils.isObject","$","VNode","[object Object]","tag","attrs","children","Utils.isFunction","Utils.get","this","assign","Utils.objectKeys","reduce","acc","replace","_","window","itr","first","next","second","done","value","id","cls","attrName","attrValue","trim","class","Utils.joinStringIfNotEmpty","$class","substr","ev","Array","isArray","child","m","Component","isComponent","_child","freeze","arg","i","splice","push","_static","dom","static","instance","state","inited","Utils.call","oninit","created","oncreate","onbeforeupdate","onupdate","view","onbeforeremove","onremove","name","copyOfName","inst","root","internalAttrs","makeEl","vTag","document","createTextNode","createElementNS","createElement","setEventListener","event","cb","Utils.data","removeEventListener","addEventListener","xforms","insertBefore","appendChild","recycleChild","removeChild","abortRedraw","applyVirtualDom","domParent","vnode","_v","vKey","attrsItr","attr","siblingIndex","changeIndex","foundKey","componentInstStack","passover","Set","applyComponentLifeCycle","method","p","componentInst","unwrapInitComponentStack","unshift","some","despawn","stack","old","replaceChild","applyXform","xform","otherEl","Text","tagName","toUpperCase","existingAttrKeys","getAttributeNames","add","includes","delete","pop","Utils.prop","componentInstStackOuterMarker","test","childNodes","removing","differentComponentInst","existingStack","timer","start","end","lastRenderTime","_redraw","now","renderCount","performance","body","e","redraw","console","warn"],"mappings":"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"}