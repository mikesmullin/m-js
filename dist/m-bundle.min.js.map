{"version":3,"file":"m-bundle.min.js","sources":["../src/utils.js","../src/m.js"],"sourcesContent":["// m, etc.\r\nexport const isEmptyArray = a => Array.isArray(a) && a.length < 1;\r\nexport const isObject = o => null != o && 'object' === typeof o; // null is #NotOurObject\r\nexport const isEmptyObject = o => isEmptyArray(Object.keys(o));\r\nexport const toArray = a => isObject(a) && a.length >= 0 ? Array.from(a) : [];\r\nexport const reduce = (initial, a, cb) => toArray(a).reduce((acc,x)=>{ cb(acc,x); return acc; }, initial);\r\nexport const objectKeys = o => isObject(o) ? Object.keys(o) : [];\r\nexport const pick = (o, ...keys) => reduce({}, objectKeys(o).filter(k=> keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const omit = (o, ...keys) => reduce({}, objectKeys(o).filter(k=>!keys.includes(k)), (acc,k)=>acc[k]=o[k]);\r\nexport const setAdd = (s, ...vals) => vals.forEach(v=>s.add(v));\r\nexport const resolve = (o, ...path) => {\r\n\t// TODO: could optimize this to generate less GC with pattern matching\r\n\t// TODO: remove anything that creates unnecessary arrays, especially use pattern matching,\r\n\t// TODO: and stop returning empty {} or [] for convenience sake. check it on iterate, instead.\r\n\tif (!isObject(o) || path.length < 1)\r\n\t\treturn { has: isObject(o) && path.length < 1, o: o, key: path[0] };\r\n\telse if (1 === path.length)\r\n\t\treturn { has: Object.hasOwnProperty.call(o, path[0]), o: o, key: path[0] };\r\n\telse return resolve(o[path.shift()], ...path);\r\n};\r\nexport const has = (o, ...path) => undefined === path[0] ? false : resolve(o, ...path).has;\r\nexport const get = (alt, o, ...path) => {\r\n\tconst r = resolve(o, ...path);\r\n\treturn r.o && r.o[r.key] || alt;\r\n};\r\nexport const set = (val, o, ...path) => {\r\n\tconst key = path.pop(), r = resolve(o, ...path);\r\n\tif (r.has) return (undefined === r.key ? r.o : r.o[r.key])[key] = val;\r\n};\r\nexport const isString = s => 'string' === typeof s;\r\nexport const isStringEmpty = s => null == s || '' === s;\r\nexport const joinStringIfNotEmpty = (a,delim,b) => isStringEmpty(a) ? b : a + delim + b;\r\nexport const isFunction = (fn,paramCount) => 'function' === typeof fn && (null == paramCount || fn.length === paramCount);\r\nexport const map = (a,cb) => null == a ? undefined : Array.isArray(a) ? a.map(cb) : isObject(a) ? Object.keys(a).map(k=>cb(a[k],k)) : a;\r\nexport const data = (()=>{\r\n\tlet l, s;\r\n\tconst r = el => new Proxy(\r\n\t\tnull != el && (s.has(el) ? s.get(el) : (l={},s.set(el,l),l)), {\r\n\t\tget: (o,k) => o ? o[k] : undefined,\r\n\t\tset: (o,k,v) => o ? (o[k] = v) : undefined,\r\n\t})\r\n\tr.flush = () => { s = new WeakMap() };\r\n\tr.flush();\r\n\treturn r;\r\n})();\r\nexport const then2 = (p,cb) => p.then(v=>cb(null, v), e=>cb(e));\r\nexport const call = (fn, ...args) => { if ( isFunction(fn)) return fn(...args) };\r\nexport const toStringValue = v => null == v ? '' : isObject(v) ? JSON.stringify(v) : v;\r\nexport const notNullOrEmptyElse = (v, defaultValue) => null != v && '' !== v ? v : defaultValue;\r\nexport const prop = function(el, ns, k, v) {\r\n\tif (null == el || arguments.length < 3) return;\r\n\tconst [key,prefix] = k.split(':').reverse();\r\n\tif (3 === arguments.length) {\r\n\t\tif (null == prefix) return notNullOrEmptyElse(el.getAttribute(key), undefined);\r\n\t\telse return notNullOrEmptyElse(el.getAttributeNS(ns[key], key), undefined);\r\n\t}\r\n\telse if (undefined === v) {\r\n\t\tif (null == prefix) el.removeAttribute(key);\r\n\t\telse el.removeAttributeNS(ns[key], key);\r\n\t}\r\n\telse {\r\n\t\tif (null == prefix) el.setAttribute(key, null == v ? '' : v);\r\n\t\telse {\r\n\t\t\tel.setAttributeNS(ns[key], key, null == v ? '' : v);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// loader\r\nexport const uid = () => Math.round(performance.now()*100).toString(16);\r\n\r\n// db\r\nexport const rescue = (cb,alt) => { try { return cb(); } catch(e) { rescue.lastError = e; return alt; } };\r\nexport const fetchLocal = (k,alt) => rescue(()=>JSON.parse(localStorage.getItem(k))) || alt;\r\n// ifChange = (testCb,onChangeCb) => { let state; return (...args) => { const v = testCb(...args); if (v !== state) { onChangeCb(v); state = v; } return v; }; };\r\nexport const saveLocal = (k,v) => { localStorage.setItem(k, JSON.stringify(v)); };\r\n\r\n// app\r\nexport const hyphenate = s => null == s ? s : s.replace(/[^a-z0-9-]+/ig, '-').replace(/-*([A-Z])-*/g, (_,s)=>'-'+s.toLowerCase()).replace(/(^-+|-+$)/g, '');\r\nexport const selector = (query,parent=document.body) => parent instanceof Node ? parent.querySelector(query) : undefined;\r\nexport const selectorAll = (query,parent=document.body) => parent instanceof Node ? Array.from(parent.querySelectorAll(query)||[]) : [];\r\nexport const orEquals = (a,b,c,d,e) => null != a ? a : null != b ? b : null != c ? c : null != d ? d : null != e ? e : null;\r\nexport const val = function(input, value) {\r\n\tif (null == input) return;\r\n\tconst hasOptions = !!selector(input, 'option');\r\n\tif (1 === arguments.length) {\r\n\t\treturn hasOptions ?\r\n\t\t\tprop(selector('option[selected]', input), null, 'value') : // select > option[selected]\r\n\t\t\tget(undefined, input, 'value'); // input[password].value\r\n\t}\r\n\telse {\r\n\t\tif (hasOptions) {\r\n\t\t\tprop(selector('option[selected]', input), null, 'selected', undefined); // delete\r\n\t\t\tprop(selectorAll(`option[value]`, input)\r\n\t\t\t\t.find(option=>option.value===value), null, 'selected', 'selected');\r\n\t\t}\r\n\t\telse set(value, input, 'value');\r\n\t}\r\n}\r\nexport const serializeForm = form =>\r\n\treduce({}, selectorAll('[name]', form), (acc,input) =>\r\n\t\tacc[prop(input, null, 'name')] = val(input));\r\nexport const request = (method, url, data) => {\r\n\tlet ok, fail;\r\n\tconst p = new Promise((a,b)=>{ok=a;fail=b});\r\n\ttry {\r\n\t\tconst xhr = new XMLHttpRequest();\r\n\t\txhr.open(method, url, true);\r\n\t\txhr.onreadystatechange = () => {\r\n\t\t\tif (4 !== xhr.readyState) return; // only proceed when request is complete\r\n\t\t\tconst data = rescue(()=>JSON.parse(xhr.responseText));\r\n\t\t\tif (200 === xhr.status) ok(data); else fail(data);\r\n\t\t};\r\n\t\txhr.setRequestHeader('Content-Type', 'application/json');\r\n\t\txhr.send(JSON.stringify(data));\r\n\t}\r\n\tcatch(e) {\r\n\t\tfail(e);\r\n\t}\r\n\treturn p;\r\n};\r\nexport const rand = (min,max) => Math.floor(Math.random() * (max - min + 1) ) + min;\r\nexport const select = a => a[rand(0, a.length-1)];\r\nexport const delay = ms => new Promise(ok=>setTimeout(ok, ms));\r\nexport const trapEvent = cb => (...args) => {\r\n\tconst e = args.pop();\r\n\te.preventDefault();\r\n\te.stopPropagation();\r\n\tcb(...args, e);\r\n\treturn false;\r\n}\r\nexport const throttle = (ms,cb) => { // leading: false, trailing: true\r\n\tlet timer;\r\n\treturn (...args) => {\r\n\t\tif (null != timer) {\r\n\t\t\ttimer = clearTimeout(timer);\r\n\t\t}\r\n\t\ttimer = setTimeout(() => {\r\n\t\t\tcb(...args);\r\n\t\t\ttimer = null;\r\n\t\t}, ms);\r\n\t};\r\n};\r\nexport const trigger = (el, event, args) => { el.dispatchEvent(new Event(event, args)); };\r\nexport const activeIf = test => test ? '.active' : '';\r\nexport const onReady = cb => {\r\n\tconst fn = () => {\r\n\t\tif ('complete' === document.readyState) cb();\r\n\t};\r\n\tdocument.onreadystatechange = fn;\r\n\tfn(); // kick-start for hot-loading cases\r\n};\r\n\r\n// ex: sortByCols(['name', 'createdAt'], 1);\r\nexport const sortByCols = (k, dir=-1) => (a,b) => (k=> (null==k || get(null,a,k)===get(null,b,k)) ? 0 : get(null,a,k)<=get(null,b,k) ? dir : (dir*-1) )(k.find(_k=>get(null,a,_k)!==get(null,b,_k)));\r\nexport const clamp = (n,min,max) => Math.max(Math.min(n, max), min);\r\n\r\n\r\n// parsers\r\nexport const is = v => null != v;\r\nexport const NA = void 0;\r\nexport const upper = s => s.toUpperCase();\r\nexport const lower = s => s.toLowerCase();\r\nexport const sum = (sum, i) => sum+i;\r\nexport const isS = isString\r\nexport const isA = a => Array.isArray(a);\r\nif (!is(Array.prototype.flat)) Array.prototype.flat = function() { return this.reduce((a,v)=>a.concat(v),[]); };\r\n\r\n/**\r\n * Chunker: A pattern-matcher and map-reducer.\r\n *\r\n * Super powerful! ie. Tokenizer, Lexer, and Semantic Analyzer in one reusable function.\r\n *\r\n *\t “Think of a unique 1-byte¹ symbol to represent each of your token types.\r\n *\t  Once everything is a string, you can use a RegExp hammer!”\r\n *\t   –Author of something\r\n *\r\n * ¹ Technically, you can use up to 3-byte UTF-8 Unicode characters–even emoji. 😂\r\n *   CAUTION: That may lead to undefined behavior and vulnerabilities within the RegExp engine.\r\n *\r\n * Operates in one of two modes:\r\n *   a) Subject-string, pattern matcher, and a token mapper, or;\r\n *   b) Corresponding tokens from the output of (a) or (b), symbol-string, pattern matcher, and a token reducer.\r\n *\r\n * @param {mixed[]} chunks - An ordered list of either all (a) subject strings, or (b) tokens of mixed type.\r\n *   This input is considered pass-by-reference, and will be overridden with the return type, for your convenience.\r\n * @param {String} symbols - (optional) A String of character symbols corresponding to the order and type of\r\n *   tokens provided in prior parameter. Ignored in mode (a), required in mode (b).\r\n * @param {RegExp} rx - Regular Expression designed to match a pattern found in one of (a) each subject string\r\n *   in the chunks list, or (b) the symbol string.\r\n * @param {Fn(matches:String[], slice:Fn(i:int)=>chunks:mixed[])=>token:mixed} matchCb -\r\n *   Callback fired per-chunk.\r\n *   Receives arguments providing context of match and, in mode (b), a mapping function which translates a symbol index\r\n *   to a token index in the chunks list.\r\n *   Expected to return a single token, or a list of multiple tokens which will be flattened, for the given match.\r\n * @param {Fn(s:String, slicedFrom:int, slicedUntil:int)=>token:mixed} betweenCb -\r\n *   (optional) Provides an opportunity to capture text found in-between patterns, which is discarded by default.\r\n *   Similar to the effect of `\"HERPderpGIGGITYderpDURR\".split(/derp/g)`, would invoke once each for \"HERP\", \"GIGGITY\",\r\n *   and \"DURR\", none of which were matched by the given RegExp pattern.\r\n *   Expected to return a single token, or a list of multiple tokens which will be flattened, for the given non-match.\r\n * @return mixed[] - An ordered list of tokens returned by `matchCb` and `betweenCb`.\r\n */\r\nexport const chunker = (chunks, symbols, rx, matchCb, betweenCb) => {\r\n\tconst r = [], _chunks = is(symbols) ? [symbols] : chunks;\r\n    let i=0,\r\n        chunk,\r\n        lastSlice,\r\n        match,\r\n        token,\r\n\r\n        pushToken = t => t ?\r\n            (isA(t) && !isS(t[0])) ?\r\n                t.forEach(t=>t && r.push(t)) :\r\n                r.push(t) :\r\n            NA,\r\n\r\n        textSlice,\r\n        pushExtra = i =>\r\n            is(betweenCb) && // if cb defined\r\n\t\t\t(textSlice = chunk.substring(lastSlice, i)) && // perform slice from last slice to given index\r\n\t\t\ttextSlice.length > 0 && // if text slice is not empty\r\n\t\t\tpushToken( // push it as a new token\r\n\t\t\t\tbetweenCb(textSlice, lastSlice, i)), // but first give betweenCb a chance to format it\r\n\r\n        mapSymbolIdxChunkIdx,\r\n        sliceChunks;\r\n\tfor (;\r\n\t\ti < _chunks.length;\r\n\t\ti++\r\n\t) {\r\n\t\tif (!isS(chunk = _chunks[i])) { // non-string chunks are not matchable by RegExp;\r\n\t\t\tis(chunk) && r.push(chunk); // forward token to output as-is, and in same position\r\n\t\t\tcontinue; // otherwise, discard null and undefined values\r\n\t\t}\r\n\r\n\t\t// perform Regular Expression pattern matching\r\n\t\tlastSlice = 0;\r\n\t\twhile (is(match = rx.exec(chunk))) { // for each match\r\n\t\t\t// internally-used contextual helper function\r\n\t\t\tmapSymbolIdxChunkIdx = i =>\r\n\t\t\t\tmatch.index + match.slice(1,Math.max(1,i))\r\n\t\t\t\t\t.map(v=>is(v) ? v.length : 0)\r\n\t\t\t\t\t.reduce(sum,0);\r\n\r\n\t\t\t// exposed contextual helper function\r\n\t\t\tsliceChunks = (symbolIndex, chunkOffset=0, chunkSliceLen) =>\r\n\t\t\t\t!is(match[symbolIndex]) ? [] :\r\n\t\t\t\t\tchunks.slice(\r\n\t\t\t\t\t\tmapSymbolIdxChunkIdx(symbolIndex) + chunkOffset,\r\n\t\t\t\t\t\tmapSymbolIdxChunkIdx(symbolIndex) + chunkOffset + (is(chunkSliceLen) ?\r\n\t\t\t\t\t\t\tchunkSliceLen :\r\n\t\t\t\t\t\t\tis(match[symbolIndex]) ?\r\n\t\t\t\t\t\t\t\tmatch[symbolIndex].length :\r\n\t\t\t\t\t\t\t\t1));\r\n\r\n\t\t\t// invoke callback to map match => token\r\n\t\t\ttoken = matchCb(match, is(symbols) && sliceChunks);\r\n\r\n\t\t\t// invoke between callback on any text preceding the match\r\n\t\t\tpushExtra(match.index); // leading [last..m.index]\r\n\r\n\t\t\tpushToken(token);\r\n\r\n\t\t\tlastSlice = match.index + match[0].length;\r\n\t\t}\r\n\r\n\t\t// invoke between callback on any text following the match\r\n\t\tpushExtra(); // trailing [last..]\r\n\t}\r\n\r\n\t// output chunks:\r\n\t// 1. by mutating input, for convenience; but also,\r\n\t// 2. by returning it\r\n\tchunks.splice(0);\r\n\tchunks.push(...r);\r\n\t// console.log('chunks', JSON.stringify(r,null,2));\r\n\treturn r;\r\n};","import * as Utils from './utils.js';\r\n\r\n// VNode is basically composable branches and traversal\r\nconst eachTag = function*(o) {\r\n\tif (!Utils.isObject(o)) return;\r\n\tfor (let k in o)\r\n\t\tif ('$'===k && 'object' !== typeof o.$) yield o.$;\r\n\t\telse if (!('$'===k[0] || '_'===k[0])) yield k;\r\n};\r\nexport let VNode = class VNode {\r\n\tconstructor(tag, attrs, ...children) {\r\n\t\tlet o;\r\n\t\tif (Utils.isFunction(Utils.get(null, tag, 'view'))) { this.$ = tag; o = this; }\r\n\t\telse { this[tag] = {}; o = this[tag]; }\r\n\t\tObject.assign(o, Utils.objectKeys(attrs).reduce((acc,k)=>{acc[k.replace(/^\\$?/, '$')]=attrs[k];return acc;},{}));\r\n\t\to._ = children;\r\n\t}\r\n};\r\nif (null == window.VNode) window.VNode = VNode; else VNode = window.VNode; // hot load (mostly)\r\n\r\nVNode.tag = o => {\r\n\tconst itr = eachTag(o), first = itr.next(), second = itr.next();\r\n\tif (second.done) return first.value;\r\n};\r\n// match group:          [1] id           [2] class           [3] attrName                        [5] attrValue\r\nconst RX_ATTRS = /\\s*(?:#([^\\s#\\.[\\]]+)|\\.([^\\s#\\.[\\]]+)|\\[\\s*([\\w:]+[^\\s=[\\]]*)?(?:\\s*=\\s*(['\"])?(.*?)\\4)?\\s*\\])\\s*/ig;\r\nVNode.attrs = function*(tag, o) {\r\n\tconst attrs = {};\r\n\ttag = tag.replace(RX_ATTRS, (...args) => {\r\n\t\tconst [/*match*/, id, cls, attrName, /*quot*/, attrValue, /*offset*/, /*str*/] = args;\r\n\t\tif (null != id)\r\n\t\t\tattrs.id = id; // last wins\r\n\t\telse if ('string' === typeof cls && '' !== cls.trim()) {\r\n\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', cls); // append space-delimited\r\n\t\t}\r\n\t\telse if (null != attrName)\r\n\t\t\tattrs[attrName] = undefined === attrValue ? null : attrValue; // merge object\r\n\t\treturn '';\r\n\t});\r\n\tif ('' === tag) tag = 'div'; // default\r\n\tyield tag; // first result is always the tag name\r\n\tif (Utils.isObject(o)) {\r\n\t\tfor (let k in o)\r\n\t\t\tif ('$class' === k) {\r\n\t\t\t\tif ('string' === typeof o.$class && '' !== o.$class.trim()) {\r\n\t\t\t\t\tattrs.class = Utils.joinStringIfNotEmpty(attrs.class, ' ', o.$class);\r\n\t\t\t\t}\r\n\t\t\t} else if ('$'===k[0] && k.length > 1)\r\n\t\t\t\tattrs[k.substr(1)] = o[k];\r\n\t}\r\n\tfor (let k in attrs)\r\n\t\tyield {\r\n\t\t\tk: k,\r\n\t\t\tev: 'on'===k.substr(0,2) ? k.substr(2) : undefined,\r\n\t\t\tv: attrs[k]\r\n\t\t};\r\n};\r\nVNode.children = function*(o) {\r\n\tif (null == o) return;\r\n\tif (Array.isArray(o)) {\r\n\t\tfor (const child of o)\r\n\t\t\tif (m.Component.isComponent(child)) yield child;\r\n\t\t\telse for (const _child of VNode.children(child))\r\n\t\t\t\tyield _child;\r\n\t}\r\n\telse if (Utils.isObject(o)) {\r\n\t\tfor (const tag of eachTag(o))\r\n\t\t\tyield Object.freeze({ [tag] : o[tag] });\r\n\t\tfor (const child of VNode.children(o._))\r\n\t\t\tyield child;\r\n\t}\r\n\telse if ('string' === typeof o || 'number' === typeof o)\r\n\t\tyield o;\r\n};\r\n\r\n// m() is basically reduced to an (optional) string parser\r\n// use it if it want, or just write the JXML directly to save cycles. your choice.\r\nlet m = (tag, ...args) => {\r\n\tconst attrs = {}, children = [];\r\n\tfor (let i=0,arg; args.length>0; i++) {\r\n\t\targ = args.shift();\r\n\t\tif (0 === i && Utils.isObject(arg) && !Array.isArray(arg) && !(arg instanceof VNode)) {\r\n\t\t\tObject.assign(attrs, arg); // attrs; merge\r\n\t\t}\r\n\t\telse if (Array.isArray(arg)) {\r\n\t\t\tchildren.splice(-1, 0, ...arg); // children; append\r\n\t\t}\r\n\t\telse {\r\n\t\t\tchildren.push(arg); // child; append\r\n\t\t}\r\n\t}\r\n\treturn new VNode(tag, attrs, ...children);\r\n};\r\nif (null == window.m) window.m = m; else m = window.m; // hot load (mostly)\r\n\r\nm.Component = class {\r\n\tconstructor(_static, attrs, ...children) {\r\n\t\tthis.dom = null;\r\n\t\tthis.static = _static;\r\n\t\tthis.attrs = attrs || {};\r\n\t\tthis.children = children || [];\r\n\t}\r\n}\r\nm.Component.isComponent = o =>  Utils.isFunction(Utils.get(null, o, '$', 'view'));\r\nm.Component.instance = (state, o) => { // wrap component in state\r\n\treturn {\r\n\t\tstate: state,\r\n\t\toninit(v) {\r\n\t\t\tif (true === state.inited) return;\r\n\t\t\tstate.inited = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oninit, v);\r\n\t\t},\r\n\t\toncreate(v) {\r\n\t\t\tif (true === state.created) return;\r\n\t\t\tstate.created = true;\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.oncreate, v);\r\n\t\t},\r\n\t\tonbeforeupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeupdate, v);\r\n\t\t},\r\n\t\tonupdate(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onupdate, v);\r\n\t\t},\r\n\t\tview(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.view, v);\r\n\t\t},\r\n\t\tonbeforeremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\treturn Utils.call(o.onbeforeremove, v);\r\n\t\t},\t\t\t\r\n\t\tonremove(v) {\r\n\t\t\tv.state = state;\r\n\t\t\tconst r = Utils.call(o.onremove, v);\r\n\t\t\tfor (const key in state) {\r\n\t\t\t\tdelete state[key];\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\t};\r\n};\r\n// lifecycle methods\r\nfor (name of [\r\n\t'oninit', // on insert, append, or replace (instantiation), before dom element exists\r\n\t'view', // every render\r\n\t'oncreate', // just after init() is complete; dom element now exists\r\n\t'onbeforeupdate', // before diff happens on a node. return false to avoid checking (like manual dirty: false)\r\n\t'onupdate', // for pre-existing dom element, post-diff on each m.render() cycle\r\n\t'onbeforeremove', // before removeChild is invoked\r\n\t'onremove' // after removeChild is invoked\r\n]) {\r\n\tconst copyOfName = name;\r\n\tm.Component[copyOfName] = (inst, dom) => {\r\n\t\tif (!Utils.isFunction(inst.static[copyOfName])) return;\r\n\t\tif (null != dom) inst.dom = dom;\r\n\t\treturn inst.static[copyOfName](inst);\r\n\t};\r\n};\r\nm.root = null;\r\nconst internalAttrs = ['', 'key', 'dirty'];\r\nconst makeEl = (ns, vTag, v=null) =>\r\n\tnull == vTag ? document.createTextNode(v) :\r\n\tnull != ns[''] ? document.createElementNS(ns[''], vTag) :\r\n\tdocument.createElement(vTag);\r\nconst setEventListener = (el, event, cb) => {\r\n\tif (cb === Utils.data(el)[event]) return;\r\n\t// note: anon functions may have the same code, but will fail above check.\r\n\t//   therefore we re-bind because is no faster way to resolve the matter.\r\n\tel.removeEventListener(event, Utils.data(el)[event], true);\r\n\tel.addEventListener(event, Utils.data(el)[event] = cb, true);\r\n};\r\nconst xforms = { insertBefore: 0, appendChild:  1, recycleChild: 2, removeChild: 3 };\r\nlet abortRedraw;\r\n// basically graph theory: walk tree, apply graph transforms, where DOM == DAG\r\nconst applyVirtualDom = (domParent, vnode/* a.k.a. fragment*/, ns/*, cb*/) => {\r\n\tlet el, v, _v, vKey, vTag, attrsItr, attr, componentInstStack = [],\r\n\tfn, siblingIndex, changeIndex, foundKey, passover = new Set([]), i = -1;\r\n\tabortRedraw = false;\r\n\tconst applyComponentLifeCycle = (method, dom) => {\r\n\t\tif (null == componentInstStack || componentInstStack.length < 1) return;\r\n\t\tlet p = [];\r\n\t\tfor (const componentInst of componentInstStack) { // child-most first\r\n\t\t\tp.push(method(componentInst, dom));\r\n\t\t\t// notice: component lifecycle methods may return undefined or a Promise,\r\n\t\t\t//   which will stall the update but only for a particular component branch.\r\n\t\t\t//   its like dirty = false, but it can apply to indexed siblings too,\r\n\t\t\t//   as long as they dont move.\r\n\t\t}\r\n\t\treturn p; // array of return values\r\n\t};\r\n\tconst unwrapInitComponentStack = v => {\r\n\t\twhile (m.Component.isComponent(v)) {\r\n\t\t\tconst attrs = {}, children = [],\r\n\t\t\t\titr = VNode.attrs('', v);\r\n\t\t\titr.next().value; // discard tag\r\n\t\t\tfor (const attr of itr) {\r\n\t\t\t\tattrs[attr.k] = attr.v;\r\n\t\t\t}\r\n\t\t\tfor (const child of VNode.children(v)) {\r\n\t\t\t\tchildren.push(child);\r\n\t\t\t}\r\n\t\t\tconst componentInst = new m.Component(v.$, attrs, ...children);\r\n\t\t\tcomponentInstStack.unshift(componentInst); // child-most first\r\n\t\t\tif (applyComponentLifeCycle(m.Component.oninit).some(v=>false===v)) {\r\n\t\t\t\tabortRedraw = true;\r\n\t\t\t\tv = null;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tv = m.Component.view(componentInst); // may return another component\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn v;\r\n\t};\r\n\tconst despawn = (stack,cb) => {\r\n\t\tconst old = componentInstStack;\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onbeforeremove);\r\n\t\tcomponentInstStack = old;\r\n\t\tcb();\r\n\t\tcomponentInstStack = stack;\r\n\t\tapplyComponentLifeCycle(m.Component.onremove);\r\n\t\tcomponentInstStack = old;\r\n\t};\r\n\tconst replaceChild = (fn, el) => {\r\n\t\tfn(xforms.insertBefore, el);\r\n\t\t// TODO: if el has children, move them to new parent before removing el?\r\n\t\t//  preserves a parent whose tag changed but children did not\r\n\t\t//  ie. test with ul -> ol and same li children\r\n\t\tfn(xforms.removeChild, el);\r\n\t};\r\n\tconst applyXform = (xform, otherEl) => {\r\n\t\tswitch (xform) {\r\n\t\t\tcase xforms.insertBefore:\r\n\t\t\tcase xforms.appendChild:\r\n\t\t\t\tel = xforms.insertBefore === xform ? // either case will create empty tag\r\n\t\t\t\t\tdomParent.insertBefore(makeEl(ns, vTag, v), otherEl) :\r\n\t\t\t\t\tdomParent.appendChild (makeEl(ns, vTag, v));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.recycleChild:\r\n\t\t\t\tif (null != vTag) {\r\n\t\t\t\t\tif (el instanceof Text || (el.tagName||'').toUpperCase() !== vTag.toUpperCase()) // node type / tag name differ\r\n\t\t\t\t\t\treplaceChild(applyXform, el);\r\n\t\t\t\t\tconst existingAttrKeys = new Set([]);\r\n\t\t\t\t\tfor (attr of el.getAttributeNames()) {\r\n\t\t\t\t\t\texistingAttrKeys.add(attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of attrsItr) {\r\n\t\t\t\t\t\tif (!internalAttrs.includes(attr.k)) { // skip internal-only attrs\r\n\t\t\t\t\t\t\texistingAttrKeys.delete(attr.k.split(':').pop());\r\n\t\t\t\t\t\t\tif (null != attr.ev) setEventListener(el, attr.ev, attr.v);\r\n\t\t\t\t\t\t\telse if (Utils.prop(el, ns, attr.k) !== attr.v) // attr value differs\r\n\t\t\t\t\t\t\t\tUtils.prop(el, ns, attr.k, attr.v); // overwrite it\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (attr of existingAttrKeys) {\r\n\t\t\t\t\t\tUtils.prop(el, ns, attr, undefined); // delete\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse { // vnode is string\r\n\t\t\t\t\tif (el instanceof Text) {\r\n\t\t\t\t\t\tif (el.data !== _v) // text node differs\r\n\t\t\t\t\t\t\tel.data = _v; // replace text\r\n\t\t\t\t\t} else replaceChild(applyXform, el); // replace node\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase xforms.removeChild:\r\n\t\t\t\tdomParent.removeChild(otherEl);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t};\r\n\r\n\t// --- BEGIN LOOP ---\r\n\tvnode = unwrapInitComponentStack(vnode);\r\n\tlet componentInstStackOuterMarker = componentInstStack.length;\r\n\tif (abortRedraw) return;\r\n\tfor (v of VNode.children(vnode)) { // single-pass dom tree mutation to target vnode state\r\n\t\tcomponentInstStack.splice(componentInstStackOuterMarker);\r\n\t\ti++;\r\n\t\twhile (passover.has(i)) i++; // skip out-of-order dom nodes with keys, modified previously\r\n\t\tv = unwrapInitComponentStack(v);\r\n\t\tif (abortRedraw) return;\r\n\t\tif (Utils.isObject(v)) { vTag = VNode.tag(v); _v = v[vTag]; }\r\n\t\telse { vTag = null; _v = v; } // literal\r\n\t\tif (null != vTag) {\r\n\t\t\tattrsItr = VNode.attrs(vTag, _v); // pull attrs from tag string, if any\r\n\t\t\tns = Object.assign({}, ns);\r\n\t\t\tfor (const k in _v) {\r\n\t\t\t\tif ('$xmlns' === k)\r\n\t\t\t\tns[''] = _v[k];\r\n\t\t\t\telse if (/^\\$xmlns:/.test(k))\r\n\t\t\t\tns[k.substr(7)] = _v[k];\r\n\t\t\t}\r\n\t\t\tvTag = attrsItr.next().value; // post-processed tag name\r\n\t\t} else attrsItr = undefined;\r\n\t\tvKey = null != vTag ? Utils.get(null, _v, '$key') : null;\r\n\t\tchangeIndex = i; // unless we find an out-of-order key\r\n\t\tfoundKey = false;\r\n\t\t\r\n\t\tif (null != vKey) { // vnode has key; find its match among dom siblings\r\n\t\t\tif (Utils.data(domParent.childNodes[i]).key === vKey) foundKey = true; // current is matching\r\n\t\t\telse {\r\n\t\t\t\tsiblingIndex = domParent.childNodes.length;\r\n\t\t\t\twhile (!foundKey && siblingIndex-- > 0) {\r\n\t\t\t\t\tif (Utils.data(domParent.childNodes[siblingIndex]).key === vKey) {\r\n\t\t\t\t\t\tchangeIndex = siblingIndex;\r\n\t\t\t\t\t\tfoundKey = true;\r\n\t\t\t\t\t\ti--; // rewind for future vnode consideration, since no match here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!foundKey) { // no matching key among siblings\r\n\t\t\t\tapplyXform(xforms.insertBefore, domParent.childNodes[i]);\r\n\t\t\t\tUtils.data(domParent.childNodes[changeIndex]).key = vKey;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (null == domParent.childNodes[changeIndex]) {\r\n\t\t\tapplyXform(xforms.appendChild);\r\n\t\t}\r\n\t\tpassover.add(changeIndex); // mark node to avoid deletion\r\n\t\tif (foundKey && false === Utils.get(null, _v, '$dirty')) continue; // manual dirty; avoid node + descendant mutation\r\n\t\t// WARNING: manual dirty requires key. replacement of node or parent will delete key.\r\n\t\t\r\n\t\tel = domParent.childNodes[changeIndex];\r\n\t\tif (false === applyComponentLifeCycle(m.Component.onbeforeupdate)) continue;\r\n\t\tif (null == Utils.data(el).removing) { // target node is waiting for mutation\r\n\r\n\t\t\tlet differentComponentInst = [];\r\n\t\t\tconst existingStack = Utils.data(el).componentInstStack;\r\n\t\t\tif (null != existingStack) {\r\n\t\t\t\tfor (let i=existingStack.length-1; i>=0; i--) {\r\n\t\t\t\t\tif (null == componentInstStack[i] || existingStack[i].state !== componentInstStack[i].state) { // not the same component instance\r\n\t\t\t\t\t\tdifferentComponentInst.push(existingStack[i]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n\t\t\t}\t\r\n\t\t\tif (differentComponentInst.length>0) {\r\n\t\t\t\tdespawn(differentComponentInst, () => {\r\n\t\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tapplyXform(xforms.recycleChild);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tUtils.data(el).componentInstStack = componentInstStack;\r\n\t\t\t\r\n\t\t\tif (Utils.isObject(v)) {\r\n\t\t\t\tapplyVirtualDom(el, _v, ns/*, cb*/); // recurse (depth-first traversal)\r\n\t\t\t\tif (abortRedraw) return;\r\n\t\t\t}\r\n\t\t\tapplyComponentLifeCycle(m.Component.oncreate, el);\r\n\t\t\tapplyComponentLifeCycle(m.Component.onupdate, el);\r\n\t\t}\r\n\t}\r\n\tsiblingIndex = domParent.childNodes.length;\r\n\twhile (siblingIndex-- > 0) { // purge nodes w/o the mark\r\n\t\tel = domParent.childNodes[siblingIndex];\r\n\t\tcomponentInstStack = Utils.data(el).componentInstStack;\r\n\t\tif (!passover.has(siblingIndex) && null == Utils.data(el).removing)\r\n\t\t\tdespawn(componentInstStack, () => {\r\n\t\t\t\tapplyXform(xforms.removeChild, el);\r\n\t\t\t});\r\n\t}\r\n};\r\nlet timer, start, end;\r\nm.lastRenderTime = 0; // warn: browser limits reliability to +/-2ms\r\nconst _redraw = now => {\r\n\tm.renderCount++;\r\n\tstart = performance.now();\r\n\ttry {\r\n\t\tapplyVirtualDom(document.body, m.root);\r\n\t}\r\n\tcatch(e) {\r\n\t\tthrow e;\r\n\t}\r\n\tfinally {\r\n\t\tend = performance.now();\r\n\t\tm.lastRenderTime = end - start;\r\n\t\ttimer = null;\r\n\t}\r\n};\r\nm.renderCount = 0;\r\nm.redraw = () => {\r\n\tif (null != timer) return;\r\n\ttimer = 1;\r\n\t_redraw();\r\n};\r\n\r\nexport default m;"],"names":["isObject","o","objectKeys","Object","keys","resolve","path","length","has","key","hasOwnProperty","call","shift","get","alt","r","isStringEmpty","s","joinStringIfNotEmpty","a","delim","b","isFunction","fn","paramCount","data","l","el","Proxy","set","k","undefined","v","flush","WeakMap","args","notNullOrEmptyElse","defaultValue","prop","ns","arguments","prefix","split","reverse","getAttribute","getAttributeNS","removeAttribute","removeAttributeNS","setAttribute","setAttributeNS","Array","prototype","flat","this","reduce","concat","eachTag","Utils.isObject","$","VNode","[object Object]","tag","attrs","children","Utils.isFunction","Utils.get","assign","Utils.objectKeys","acc","replace","_","window","itr","first","next","second","done","value","id","cls","attrName","attrValue","trim","class","Utils.joinStringIfNotEmpty","$class","substr","ev","isArray","child","m","Component","isComponent","_child","freeze","arg","i","splice","push","_static","dom","static","instance","state","inited","Utils.call","oninit","created","oncreate","onbeforeupdate","onupdate","view","onbeforeremove","onremove","name","copyOfName","inst","root","internalAttrs","makeEl","vTag","document","createTextNode","createElementNS","createElement","setEventListener","event","cb","Utils.data","removeEventListener","addEventListener","xforms","insertBefore","appendChild","recycleChild","removeChild","abortRedraw","applyVirtualDom","domParent","vnode","_v","vKey","attrsItr","attr","siblingIndex","changeIndex","foundKey","componentInstStack","passover","Set","applyComponentLifeCycle","method","p","componentInst","unwrapInitComponentStack","unshift","some","despawn","stack","old","replaceChild","applyXform","xform","otherEl","Text","tagName","toUpperCase","existingAttrKeys","getAttributeNames","add","includes","delete","pop","Utils.prop","componentInstStackOuterMarker","test","childNodes","removing","differentComponentInst","existingStack","timer","start","end","lastRenderTime","_redraw","now","renderCount","performance","body","e","redraw"],"mappings":"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"}